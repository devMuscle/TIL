# 자바의 정석 3판

[링크](https://www.yes24.com/Product/Goods/24259565)

# Chapter 10. 날짜와 시간 & 형식화

## 날짜와 시간

### Calendar 와 Date

- **Date**는 날짜와 시간을 다룰 목적으로 JDK1.0 부터 제공되는 클래스다
- **Calendar**는 날짜와 시간을 다룰 목적으로 JDK1.1 부터 제공되는 클래스다
  - getInstance() 메서드를 호출해 인스턴스를 반환 받는 형식을 사용한다
    - **최소한의 변경으로 프로그램이 동작하기 위함이다.**
      즉, 다른 종류의 인스턴스를 필요로 하는 경우에 코드를 변경해야 하는데
      메서드를 통해서 얻어오면 코드를 변경하지 않아도 된다.
  - 날짜 시간을 조정하는 메서드, 시간상의 전후를 비교하는 메서드를 제공한다

## 형식화 클래스

### Decimal Format

숫자를 형식화 하는데 사용한다

```java
double number = 1234567.89;
DecimalFormat df = new DecimalFormat("#.#E0");
String result = df.format(number);

System.out.println("result = " + result);
```



### SimpleDateFormat

날짜 데이터를 원하는 형태로 출력하게 도와준다

```java
Date today = new Date();
SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
String result = df.format(today);
```

parse를 이용해서 format에 맞춰져있는 String 형태의 날짜 정보를 Date로 추출할 수 있다

```java
Date date = df.parse("1999년-1월-12일");
```



### ChoiceFormat

특정 범위에 속하는 값을 문자열로 반환해준다.
연속적 또는 불연속적 범위의 값들을 if 문이나 switch 문 보다 쉽게 처리할 수도 있다.

```java
double[] limits = {60,70,80,90}; //낮은 값부터 큰 값의 순서로 작성해야 함
//limits, grades 간의 순서와 개수를 맞추어야 한다.
String[] grades = {"D", "C", "B", "A"};

int[] scores = {100, 95, 88, 80, 62, 60, 70};

ChoiceFormat form = new ChoiceFormat(limits, grades);

for(int score : scores) {
    System.out.println(score + " : " + form.format(score));
}

String pattern = "60#D|70#C|80<B|90#A";

ChoiceFormat form2 = new ChoiceFormat(pattern);

System.out.println("= form2 =");
for(int score : scores) {
    System.out.println(score + " : " + form2.format(score));
}
```



### MessageFormat

데이터를 정해진 형식에 맞게 출력할 수 있도록 도와준다

```java
String msg = "Name: {0} \nTel: {1} \nAge:{2} \nBirthday: {3}";

Object[] arguments = {"홍지표", "010-1234-5678", "25", "03-01"};

String result = MessageFormat.format(msg, arguments);
System.out.println(result);

//같은 형식에서 우너하는 값 추출
String[] data = {"INSERT ('홍지표', '010-123-456', '25', '12-25')", "INSERT ('김자바', '010-456-789', '99', '03-01')"};

String pattern = "INSERT ({0}, {1}, {2}, {3})";
MessageFormat mf = new MessageFormat(pattern);

System.out.println("= parse example =");

for(String datum : data) {
  Object[] extractData = mf.parse(datum);

  for(Object extractDatum : extractData) {
      System.out.print(extractDatum + " ");
  }
  System.out.println();
}
```



## java.time 패키지

JDK1.8 부터 추가된 패키지다.

기존 Calendar 클래스는 변경 가능하므로, **멀티 쓰레드 환경에서 안전하지 못하다.**
이 점을 보완하고자 java.time에는 String 처럼 불변한 객체를 다룬다.
그래서 기존의 객체를 변경하지 않고 새로운 객체를 반환하는 형식을 사용한다. 

**LocalDate**

- 날짜를 다룰때 사용하는 클래스다

**LocalTime**

- 시간을 다룰때 사용하는 클래스다

**LocalDateTime**

- 날짜, 시간을 모두 다룰때 사용하는 클래스다

**Instant**

- 에포크 타임부터 경과된 시간을 나노초 단위로 표현한다.

**ZonedDateTime**

- LocalDateTime에 시간대를 추가한 클래스다.

**Period**

- 날짜의 차이를 다루는 클래스다

**Duration**

- 시간의 차이를 다루는 클래스다

**DateTimeFormatter**

- 날짜와 시간을 형식화 하는데 사용한다



# Chapter 11. 컬렉션 프레임웍

## 컬렉션 프레임웍 (Collection Framework)

컬렉션 프레임웍이란 ‘데이터 군을 저장하는 클래스들을 표준화한 설계’를 뜻한다.
다수의 데이터를 다루는데 필요한 다양하고 풍부한 클새들을 제공해서 편리하다.
또한 인터페이스와 다형성을 이용한 객체지향적 설계를 통해 표준화되어 있기 때문에
사용법을 익히기에도 편리하고 재사용성이 높은 코드를 작성할 수 있다.

### 컬렉션 프레임웍의 핵심 인터페이스

컬렉션 프레임웍에서는 컬렉션을 크게 3타입이 존재하여 3개의 인터페이스를 정의햇다.
`List`와 `Set` 의 공통된 부분을 다시 뽑아서 `Collection` 을 추가로 정의 하였다.

**List**

- 순서가 있는 데이터의 집합, 데이터의 중복을 허용

**Set**

- 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않음

**Map**

- key, value의 쌍으로 이루어진 데이터의 집합
- 순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.

**Collection 인터페이스**

컬렉션 클래스에 저장된 데이터를 읽고, 추가하고 삭제하기 위해 기본적인 메서드 정의
보통 성공시 true, 실패시 false를 반환.
Java API 문서에 `Object` 가 아닌 `E` 로 표현되어 있는데 이는 제네릭스에 의한 표기

**List 인터페이스**

중복을 허용하면서 저장 순서가 유지되는 컬렉션을 구현하는데 사용된다.

**Set 인터페이스**

중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 구현하는데 사용된다.
구현한 클래스로는 `HashSet`, `TreeSet` 등이 있다.

**Map 인터페이스**

key, value를 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는 데 사용된다.
키는 중복될 수 없지만, 값은 중복을 허용, 중복된 키를 저장하면 마지막에 저장된 값이
남게 된다.
구현한 클래스로는 `HashTable`, `HashMap`, `LinkedHashMap`, `SortedMap`, `TreeMap`등

**Map.Entry 인터페이스**

`Map` 인터페이스의 내부 인터페이스이다. 저장되는 key-value 쌍을 다루기 위해
내부적으로 정의해놓았다. 보다 객체지향적으로 설계하도록 유도하기 위한 것이다.

### `ArrayList`

기존의 `Vector` 를 개선한 것으로 구현원리와 기능이 거의 동일하다.
`Object` 배열을 이용해서 데이터를 순차적으로 저장하고, 더 이상 저장할 공간이 없으면
더 큰 새로운 배열을 생성해서 내용을 복사한다.

`ArrayList` 나 `Vector` 같이 배열을 이용한 자료구조는 데이털르 읽어오고 저장하는
효율이 좋지만, 용량을 변경해야 할 때는 새로운 배열을 생성한 후 기존의 배열로부터
새로 생성된 배열로 데이터를 복사해야하기 때문에 상당히 효율이 떨어진다.
그래서 처음 생성할때 충분한 용량의 인스턴스를 생성하는것이 좋다.

### `LinkedList`

배열은 가장 기본적인 형태의 자료구조로 구조가 가단하며 사용하기 쉽고 데이터를
읽어오는데 걸리는 시간이 가장 빠르다는 장점을 가지고 있지만 단점도 있다.

1. **크기를 변경할 수 없다.**
    - 새로운 배열을 생성해서 데이터를 복사하는 작업이 필요하다.
    - 실행속도 향상을 위해 충분히 큰 크기의 배열을 생성하면 메모리가 낭비 된다.
2. **비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.**
    - 차례대로 데이터를 추가하고 마지막에서부터 데이터를 삭제하는 것은 빠르지만
    데이터를 중간에 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야 한다.

이러한 단점을 보완하기 위해서 `Liked List` 라는 자료구조가 고안되었다.
배열은 모든 데이터가 연속적으로 존재하지만 `LinkedList` 는 불연속적으로 존재하는 데이터를 서로 연결(link)한 형태로 구성되어 있다.



**결론**

1. **순차적으로 추가/삭제하는 경우에는 `ArrayList`가 `LinkedList`보다 빠르다.**
    - 저장공간 부족으로 새로운  `ArrayList` 를 생성해야 하는 경우
    `LinkedList` 가 더 빠를 수 있으니 초기 용량을 잘 확보하자.
    - `ArrayList` 는 마지막 데이터부터 삭제할 경우 각 요소들의 재배치가 필요하지 않기 떄문에 상당히 빠르다. (요소의 값을 null로 바꾸면 됨)
2. **중간 데이터를 추가/삭제하는 경우에는 `LinkedList` 가 `ArrayList` 보다 빠르다.**
    - 중간 요소를 삭제하는 경우 `LinkedList` 가 더 빠르다.
    `LinkedList` 는 연결만 변경해주면 되지만, `LinkedList` 는 추가 공간 확보나
    빈 공간을 채워야하기 때문이다.

|   컬렉션   | 읽기(접근시간) | 추가/삭제 |                           비고                           |
| :--------: | :------------: | :-------: | :------------------------------------------------------: |
| ArrayList  |     빠르다     |  느리다   | 순차적인 추가삭제는 더 빠름.<br />비효율적인 메모리 사용 |
| LinkedList |     느리다     |  빠르다   |            데이터가 많을수록 접근성이 떨어짐             |





# Chapter 11. 컬렉션 프레임웍

## 1. 컬렉션 프레임웍 (Collection Framework)

컬렉션 프레임웍이란, '데이터 군을 저장하는 클래스들을 표준화한 설계'를 뜻한다.

JDK 1.2부터 컬렉션 프레임웍이 등장하면서 다양한 종류의 컬렉션 클래스가 추가되고
모든 컬렉션 클래스를 표준화된 방식으로 다룰 수 있도록 체계화 하였다.



### 1.1 컬렉션 프레임웍의 핵심 인터페이스

클렉션 프레임웍에서는 컬렉션을 크게 3가지 존재한다고 보고 3개의 인터페이스를 정의하였다.
그리고 `List`와 `Set`의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 `Collection`을 추가로 정의하였다.

`Vector` , `Stack` , `HashTable` , `Properties` 와 같은 클래스들은 컬렉션 프레임웍 이만들어지기 이전부터 존재하던 것이기 때문에
컬렉션 프레임웍의 명명법을 따르지 않는다.
가능한 새로 추가된 `ArrayList`와 `HashMap`을 사용하자

**`List` 인터페이스**

중복을 허용하면서 저장 순서가 유지되는 컬렉션을 구현하는데 사용된다.



**`Set` 인터페이스**

중복을 허용하지 않고 저장순서가 유지되지 않는 컬렉션 클래스를 구현하는데 사용된다.



**`Map` 인터페이스**

키와 값을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는 데 사용된다.
키는 중복될 수 없지만 값은 중복을 허용한다.
중복된 키와 값을 저장하면 기존의 값은 없어지고 마지막에 저장된 값이 남게된다.



**`Map.Entry` 인터페이스**

`Map` 인터페이스의 내부 인터페이스이다.
`Map`에 저장되는 key-value 쌍을 다루기 위해 내부적으로 `Entry` 인터페이스를 정의해 놓았다.



### 1.2 `ArrayList`

기존의 `Vector`를 개선한 것으로 구현원리와 기능적인 측면에서 동일하다 할 수 있다.
`Object` 배열을 이용해서 데이터를 순차적으로 저장한다.
배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해서
기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장된다.

따라서 데이터를 읽어오고 저장하는 데는 효율이 좋지만, 용량을 변경해야할 때는 효율이 상당히 떨어진다.

생성할 때 지정한 크기보다 더 많은 객체를 저장하면 자동적으로 크기가 늘어나기는 하지만
이 과정에서 처리시간이 많이 소요되기에 초기에 여유있는 크기로 하는 것이 좋다.



### 1.3 `LinkedList`

배열의 크기를 변경할 수 없는 점과, 비순차적인 데이터의 추가 삭제에 시간이 많이 걸린다는 단점을 보완한 자료구조다.

`LinkedList`는 불연속적으로 존재하는 데이터를 서로 연결한 형태로 구성되어 있다.



### 1.4 `Stack`과 `Queue`

`Stack`은 마지막에 저장한 데이터를 가장 먼저 꺼내게 되는 LIFO 구조다.
`Queue`는 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 FIFO 구조다.



**`PriorityQueue`**

`Queue` 인터페이스의 구현체 중의 하나로, 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼내게 된다는 특징이 있다.
`null` 을 저장하면 `NullPointerException`이 발생한다.
저장공간으로 배열을 사용하며, 각 요소를 `heap`이라는 자료구조의 형태로 저장한다.
`heap`은 이진 트리의 한 종류로 가장 큰값이나 가장 작은 갑승ㄹ 빠르게 찾을 수 있다는 특징이 있다.



**`Deque` (Double-Ended Queue)**

`Queue`의 변형으로, 양쪽 끝에 추가/삭제가 가능하다.
`Deque`의 조상은 `Queue`이며, 구현체로는 `ArrayDeque`와 `LinkedList` 등이 있다.



### 1.5 `Iterator`, `ListIterator`, `Enumeration`

모두 컬렉션에 젖아된 요소를 접근하는데 사용되는 인터페이스다.
`Enumeration`은 `Iterator`의 구버전이며, `ListIterator`는 `Iterator`의 기능을 향상 시킨 것이다.



**`Iterator`** 

컬렉션 프레임웍에서는 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화하였다.
컬렉션에 저장된 각 요소에 접근하는 긴으을 가진 `Iterator` 인터페이스를 정의하고,
`Collectrion` 인터페이스에는 `Iterator`를 반환하는 `iterator()`를 정의하고 있다.



**`ListIterator`와 `Enumeration`**

`Enumeration`은 컬렉션 프레임웍이 만들어지기 이전에 사용하던 것으로 `Iterator`의 구버젼이라고 생각하면 된다.
가능하면 `Iterator`를 사용하자.
`ListIterator` 는 `Iterator`를 상속받아서 기능을 추가한것으로, 
`Iterator`는 단방향으로 이동할 수 있지만 `ListIterator`는 양방향으로 이동 가능하다.
하지만 `ArrayList` 나 `LinkedList` 같이 `List` 인터페이스를 구현한 컬렉션에서만 사용할 수 있다.



### 1.6 `Arrays`

`Arrays` 클래스에는 배열을 다루는데 유용한 메서드가 정의되어 있다.

**배열의 복사 - `copyOf()`, `copyOfRange()`**

**배열 채우기 - `fill()`, `setAll()`**

**배열의 정렬과 검색 - `sort()`, `binarySearch()`**

**문자열의 비교와 출력 - `equals()`, `toString()`**

`toString()`은 일차원 배열에만 사용할 수 있으므로, 다차원 배열에는 `deepToString()`을 사용해야 한다.
`equals()`도 두 배열에 저장된 요소를 비교하는데 일차원 배열에만 사용할 수 있으므로,
다차원 배열에는 `deepToEquals()`를 사용해야 한다.

**배열을 `List`로 변환 - `asList(Object... a)`**

`asList()`가 반환한 `List`의 크기를 변경할 수 없다.
즉, 추가 삭제가 불가능하다. 저장된 내용은 변경 가능하다.
크기를 변경할 수 있는 `List`가 필요하면 `new ArrayList<>(Arrays.asList(1,2,3))` 이런식으로 사용하면 된다.

**`parallelXXX(), spliterator(), stream()`**

'parallel' 로 시작하는 이름의 메서드들이 있는데, 이 메서드들은 보다 빠른 결과를 얻기 위해
여러 쓰레드가 작업을 나누어 처리하도록 한다.
`spliterator()`는 여러 쓰레드가 처리할 수 있게 하나의 작어블 여러 작업으로 나누는 `Spliterator`를 반환하며,
`stream()`은 컬렉션을 스트림으로 변환한다.



### 1.7 `Comparator`와 `Comparable`

`Arrays.sort()`를 호출만 하면 알아서 정렬하는 것처럼 보이지만,
사실은 `Character`클래스의 `Comparable`의 구현에 의해 정렬되었던 것이다.

`Comparator`와 `Comparable`은 모두 인터페이스로 컬렉션을 정렬하는데 필요한 메서드를 정의하고 있으며,
`Comparable`을 구현하고 있는 클래스들은 같은 타입의 인스턴스끼리 서로 비교할 수 있는 클래스들,
주로 `Integer`와 같은 `wrapper`클래스와 `String`, `Date`, `File`과 같은 것들이며 기본적으로 오름차순 정렬되도록 구현되어 있다.
그래서 `Comparable`을 구현한 클래스는 정렬이 가능하다는 것을 의미한다.

`Comparator`는 기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용한다.

`String`의 `Comparable`은 유니코드의 순서가 작은 값에서 부터 큰 값으로, 즉 사전 순으로 정렬되도록 작성되어 있다.



### 1.8 `HashSet`

`Set`인터페이스를 구현한 가장 대표적인 컬렉션이며, 중복된 요소를 저장하지 않는다.
`add()` 나 `addAll()` 로 원소를 추가시에 중복된 원소가 있으면 `false`를 반환하여, 추가에 실패한 것을 알려준다.

`Set`을 구현한 컬렉션 클래스는 순서를 유지하지 않기 때문에, 중복을 제거하는 동시에 저장한 순서를 유지하고자 한다면
`HashSet` 대신 `LinkedHashSet`을 사용해야 한다.

`HashSet`은 같은 것인지 판별할떄 `equals()` 와 `hashCode()`를 호출하기 때문에
목적에 맞게 해당 메서드들을 오버라이딩 해야한다.

`hashCode()`는 3가지를 만족해야 한다.

1. 실행 중인 애플리케이션 내의 동이한 객체에 대해서 여러 번 `hashCode()`를 호출해도 동일한 `int`값을 반환해야 한다.
   하지만, 실행시마다 동일한 int값을 반환할 필요는 없다.
2. `equals()`메서드를 이용한 비교에 의해서 `true`를 얻은 두 객체에 대해 각각 `hashCode()`를 호출해서 얻은 결과는
   반드시 같아야 한다.
3. `euqals()` 메서드를 호출했을 때 `false`를 반환하는 두 객체는 `hashCode()`호출에 대해 같은 `int`값을 반환하는 경우가 있어도
   괜찮지만, 해싱을 사용하는 컬렉션의 성능을 향상시키기 위해서는 다른 `int`값을 반환하는 것이 좋다.



### 1.9 `TreeSet`

이진 검색 트리라는 자료구조의 형태로 데이털르 저장하는 컬렉션 클래스이다.
이진 검색 트리는 정렬, 검색, 범위검색에 높은 성능을 보이는 자료구조이며 `TreeSet`은 이진 검색 트리의 성능을 향상시킨
'레드-블랙 트리'로 구현되어 있다.



**이진 검색 트리는**

- 모든 노드는 최대 두 개의 자식 노드를 가질 수 있다.
- 왼쪽 자식노드의 값은 부모노드의 값보다 작고 오른쪽 자식노드의 값은 부모노드의 값보다 커야한다.
- 노드의 추가 삭제에 시간이 걸린다. (순차적으로 저장하지 않으므로)
- 검색 (범위검색)과 정렬에 유리하다
- 중복된 값을 저장하지 못한다



### 1.10 `HashMap`과 `Hashtable`

`Hashtable` 보다는 새로운 버전인 `HashMap`을 사용하는 것을 권장한다.

`HashMap`은 `Map`을 구현했으므로, 키와 값을 묶어서 하나의 데이터로 저장한다는 특징을 갖는다.
그리고 해싱을 사용하기 때문에 많은 양의 데이터를 검색하는데 있어서 뛰어난 성능을 보인다.

키는 저장된 값을 찾는데 사용되는 것이기 때문에 컬렉션 내에서 유일해야 한다.



**해싱과 해시함수**

해싱이란 해시함수를 이용해서 데이터를 해시테이블에 저장하고 검색하는 기법을 말한다.
해시함수는 데이터가 저장되어 있는 곳을 알려 주기 때문에 다량의 데이터 중에서도 원하는 데이터를 빠르게 찾을 수 있다.

저장할 데이터의 키를 해시함수에 넣으면 배열의 한 요소를 얻게 되고, 다시 그 곳에 연결되어 있는 링크드 리스트에 저장하게 된다.
배열의 각 요소에는 링크드 리스트가 저장되어 있어서 실제 저장한 데이터는 링크드 리스트에 담겨지게 된다.

링크드 리스트는 검색에 불리한 자료구조이기 때문에 크기가 커질수록 검색 속도가 떨어진다.
반면 배열은 배열의 크기가 커져도, 원하는 요소가 몇 번째에 있는 지만 알면 빠르게 원하는 값을 찾을 수 있다.

그래서 해싱을 구현하는 과정에서 제일 중요한 것은 해시함수의 알고리즘이다.
실제로는 해싱을 구현한 컬렉션 클래스에서는 `Object`클래스에 정의된 `hasCode()`를 해시함수로 사용한다.
`Object`클래스에 정의된 `hashCode()`는 객체의 주소를 이용하는 알고리즘으로 해시코드를 만들어 내기 때문에
모든 객체에 대해 `hashCode()`를 호출한 결과가 서로 유일한 훌륭한 방법이다.

`String` 클래스의 경우 `Object`로부터 상속받은 `hashCode()`를 오버라이딩해서 문자열의 내용으로 해시코드를 만들어 낸다.
그래서 서로 다른 `String`인스턴스일지라도 같은 내용의 문자열을 가졌다면 `hashCode()`를 호출하면 같은 해시코드를 얻는다.



### 1.11 `TreeMap`

이진검색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장한다.
그래서 검색과 정렬에 적합한 컬렉션 클래스이다.
검색에 관한한 대부분의 경우에서 `HashMap`이 `TreeMap`보다 더 뛰어나므로 `HashMap`을 사용하는 것이 좋다.
다만 범위검색이나 정렬이 필요한 경우에는 `TreeMap`을 사용하자.



### 1.12 `Properties`

`HashMAp`의 구버전인 `Hashtable`을 상속받아 구현한 것으로, `Hashtable`은 키와 값을 (`Object`, `Object`) 의 형태로 저장하는데
`Properties`는 (`String`, `String`) 의 형태로 저장하는 보다 단순화된 컬렉션클래스이다.

주로 애플리케이션의 환경설정과 관련된 속성을 저장하는데 사용되며 데이터를 파일로부터 읽고 쓰는 편리한 기능을 제공한다.

 

### 1.13 `Collections`

`Arrays`가 배열과 관련된 메서드를 제공하는 것처럼, `Collections`는 컬렉션과 관된 메서드를 제공한다.



**컬렉션의 동기화**

멀티 쓰레드 프로그래밍에서는 하나의 객체를 여러 쓰레드가 동시에 접근 할 수 있기 때문에
데이터의 일관성을 유지하기 위해서는 공유되는 객체에 동기화가 필요하다.

`Vector` 와 `Hashtable` 과 같은 구버전의 클래스들은 자체적으로 동기화 처리가 되어 있는데,
멀티쓰레드 프로그래밍이 아닌 경우에는 불필요한 기능이 되어 성능을 떨어뜨리는 요인이 된다.

그래서 새로 추가된 `ArrayList`와 `HashMap`과 같은 컬렉션은 동기화를 자체적으로 처리하지 않고 필요한 경우에만 `java.util.Collections` 클래스의 동기화 메서드를 이용해서 동기화처리가 가능하도록 변경하였다.

사용 방법은 아래와 같다.

```java
List syncList = Collections.synchronizedList(new ArrayList(...)));
```



**변경불가 컬렉션 만들기**

컬렉션에 저장된 데이터를 보호하기 위해서 컬렉션을 변경할 수 없게, 즉 읽기전용으로 만들어야할 때가 있다.
주로 멀티 쓰레드 프로그래밍에서 여러 쓰레드가 하나의 컬렉션을 공유하다보면 데이터가 손상될 수 있는데,
메서드를 활용하여 이를 방지할 수 있다.



**싱글톤 컬렉션 만들기**

인스턴스를 `new`연산자가 아닌 메서드를 통해서만 생성할 수 있게 함으로써 생성할 수 있는 인스턴스의 개수를 제한하는 방법이 있다.
이러한 기능을 제공하는 것이 바로 `singleton`으로 시작하는 메서드이다.

매개변수로 저장할 요소를 지정하면, 해당 요소를 저장하는 컬렉션을 반환한다.
그리고 반환된 컬렉션은 변경할 수 없다.



**한 종류의 객체만 저장하는 컬렉션 만들기**

컬렉션에 모든 종류의 객체를 저장할 수 있다는 것은 장점이기도하고 단점이기도 하다.
대부분의 경우 한 종류의 객체를 저장하며, 컬렉션에 지정된 종류의 객체만 저장할 수 있도록 제한하고 싶을때 메서드를 활용하면 된다.

사용방법은 다음과 같이 두 번째 매개변수에 저장할 객체의 클래스를 지정하면 된다.

```java
List list = new ArrayList();
List checkedList = checkedList(list, String.class);
```

컬렉션에 저장할 요소의 타입을 제한하는 것은 지네릭스로 간단히 처리할 수 있는데도
이런 메서드들을 제공하는 이유는 호환성 때문이다.
지네릭스는 JDK 1.5부터 도입된 기능으로 JDK 1.5 이전에 작성된 코드를 사용할 때는 이 메서드들이 필요할 수 있다.
