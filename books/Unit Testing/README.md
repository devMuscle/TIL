# Unit Testing

## 1. 단위 테스트의 목표

### 단위 테스트의 목표

- 단위 테스트가 더 나은 설계로 이어질 수는 있지만, 이는 부수적 효과이며 주 목표는 아니다
- 단위 테스트의 목표는 **소프트웨어 프로젝트의 지속가능한 성장을 가능하게 하는 것**이다



### 코드 커버리지 (Code Coverage, Test Coverage)

- **코드 커버리지 (테스트 커버리지) = 제품 코드 라인 수 / 전체 라인 수**

- 커버리지 지표는 괜찮은 부정 지표이지만 좋은 긍정 지표는 아니다

  - 코드 커버리지가 낮으면 테스트가 충분치 않다는 좋은 증거지만
    코드 커버리지가 높다고 양질의 테스트코드라는 것은 보장하지 않는다

  - [예시](https://github.com/devMuscle/TIL/blob/main/unit-testing/unit-testing/src/test/java/me/devMuscle/unittesting/TestCoverageTest.java)

    - isStringLong1 의 경우 코드 커버리지가 80% 이지만
      isStringLong2 의 경우 코드 커버리지가 100% 이다

    - 테스트 스위트를 개선하지 않았지만 커버리지 숫자가 변화 하였다

      

### 분기 커버리지 (Branch Coverage)

- 분기 커버리지는 코드 커버리지의 단점을 극복하는데 도움이 되어, 더 정확한 결과를 제공한다
- **분기 커버리지 = 통과 분기 / 전체 분기 수**



### 커버리지 지표에 대한 문제점

- **테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다**

  - 테스트 대상 시스템이 낸 결과가 정확히 예상되는 결과인지 확인해야 한다
  - 결과가 여러개 일 수 있다
  - 지표가 의미 있으려면, 모든 측정 지표를 검증해야 한다
  - [예시](https://github.com/devMuscle/TIL/blob/main/unit-testing/unit-testing/src/test/java/me/devMuscle/unittesting/TestCoverageTest.java)
    - isStringLong 메서드에 대한 테스트에서 return 값에 대한 검증만 하지
      wasLastStringLong 에 대입하는 결과에 대해서는 검증하지 않는다
    - 검증이 없는 테스트의 경우 언제나 통과한다

- **외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다**

  - 분기 커버리지 지표가 100%로 표시되며, 메서드 결과의 모든 구성 요소를 검증하지만 테스트가 완벽하지 않다
  - [예시](https://github.com/devMuscle/TIL/blob/main/unit-testing/unit-testing/src/test/java/me/devMuscle/unittesting/TestCoverageTest.java)
    - Interger.parseInt 를 수행시에 입력 매개변수에 따라 숨어있는 분기가 많다
      - Null 값
      - 빈 문자열
      - 정수가 아님
      - 너무 긴 문자열

  - 수많은 예외상황에 빠질 수 있지만, 테스트에서 모든 예외 상황을 다루는지 확인할 방법이 없다
  - 모든 코드 경로를 고려해야하는 것이 아니라
    해당 지표로는 단위 테스트가 얼마나 좋은지/나쁜지 판단할 수 없다는 것을 보여준다



### 무엇이 성공적인 테스트 스위트를 만드는가?

- 테스트 스위트가 얼마나 좋은지는 자동으로 확인할 수 없다.
  개인의 판단에 맡겨야 한다.
- 성공적인 테스트 스위트의 특성
  - **개발 주기에 통합되어 있다**
    - 이상적으로는 코드가 변경될때 마다 아무리 작은것이라도 테스트를 실행해야 한다
  - **코드베이스에서 가장 중요한 부분만을 대상으로 한다**
    - 시스템의 가장 중요한 부분에 대한 테스트 노력을 기울이고,
      다른 부분은 간략하게 또는 간접적으로 검증하는 것이 좋다
  - **최소한의 유지비로 최대의 가치를 이끌어낸다**
    - 가치가 유지비를 상회하는 테스트만 스위트에 유지하는 것이 중요하다



## 2. 단위 테스트란 무엇인가

### '단위 테스트'의 정의

- **단위 테스트의 중요한 세가지 속성**
  - 작은 코드 조각 (단위라고도 함)을 검증하고
  - 빠르게 수행하고
  - 격리된 방식으로 처리하는 자동화된 테스트다

- **격리 문제에 대한 접근 차이**

  - **런던파**

    - 테스트 대상 시스템에서 협력자를 격리하는것으로 본다

      **협력자** : 공유가능하거나 변경 가능한 의존성

    - 모든 의존성을 테스트 대역(Test Double)로 대체한다

    - 외부 영향과 분리하여 테스트 대상에만 집중

    - **장점**

      - 의존성과 별개로 단위테스트 수행 가능
      - 테스트가 실패하면 어느 부분이 고장났는지 확실히 알 수 있다

  - **고전파**

    - 단위 테스트 끼리만 격리 (코드 끼리는 격리 안해도 된다)

- **의존성**

  - **공유 의존성**

    - 테스트간에 공유되고 서로 결과에 영향을 줄 수 있는 의존성
    - static 필드나 데이터베이스 같은 경우
    - **테스트 실행 속도를 높이기 위해 대체 하기도 함**
      - 거의 실행 프로세스 외부에 존재하여 시간이 오래 걸린다.
        단위 테스트의 두 번째 속성으로 빨리 실행해야 하는 필요성이 있다.
  - **비공개 의존성**
  
    - 공유하지 않는 의존성
  - **외부 의존성**

    - 애플리케이션 실행 프로세스 외부의 의존성
    - 데이터베이스 같은 경우
    - 외부 의존성이지만 공유 의존성은 아닐 수 있다
      - 각 테스트 실행 전에 데이터베이스를 도커 컨테이너로 시작
      - 외부 읽기 전용 API (수정할 수 없는 경우)
  - **휘발성 의존성**
    - 런타임 환경의 설정 및 구성을 요구
    
      - 데이터베이스,  API 서비스
    
    - 비결정적 동작을 포함
    
      - 각 호출에 대한 다른 결과 반환
    
      - 난수 생성기, 현재 날짜 계산기
    



### 단위 테스트의 런던파와 고전파

- **의견 차이가 생기는 지점**

  - 격리 요구 사항
  - 테스트 대상 조각(단위)의 구성 요소
  - 의존성 처리

  |            |  격리 주체  |         단위의 크기          |   테스트 대역 사용 대상    |
  | ---------- | :---------: | :--------------------------: | :------------------------: |
  | **런던파** |    단위     |         단일 클래스          | 불변 의존성 외 모든 의존성 |
  | **고전파** | 단위 테스트 | 단일 클래스 또는 클래스 세트 |        공유 의존성         |

  - [예시](https://github.com/devMuscle/TIL/tree/main/unit-testing/unit-testing/src/test/java/me/devMuscle/unittesting/chapter2)
    - Customer는 Product와 Store에 의존중인데
      - [런던파](https://github.com/devMuscle/TIL/blob/main/unit-testing/unit-testing/src/test/java/me/devMuscle/unittesting/chapter2/LondonStyleTest.java)의 경우 비공유 의존성인 Store가 불변 의존성이 아니기에 테스트 대역으로 대체 하였다.
        (Product는 enum이기에 불변하는 값 객체이지만 Store의 경우 내부 상태가 변경될 가능성은 있다)
      - [고전파](https://github.com/devMuscle/TIL/blob/main/unit-testing/unit-testing/src/test/java/me/devMuscle/unittesting/chapter2/TraditionalStyleTest.java)의 경우 둘 다 비공유 의존성이기에 테스트 대역으로 대체하지 않고 실제 객체를 사용하였다.

- **의존성을 다루는 방법**

  - **런던파**
    - 불변 객체는 테스트 대역으로 교체하지 않는다
      (위의 예시의 경우 Product에 해당)
    - 변경 가능한 비공개 의존성은 테스트 대역으로 교체한다
      (위의 예시의 경우 Store에 해당)
  - **고전파**
    - 공유 의존성을 테스트 대역으로 교체한다
  
  

### 고전파 vs 런던파 비교

**런던파의 장점**

- **한 번에 한 클래스만 테스트 가능하다**
  - 입자성 (granularity) 가 좋다, 테스트가 세밀해서 (fine-grained) 한 번에 한 클래스만 확인한다
  - **단위 테스트의 단위**
    - 런던파는 클래스를 단위로 간주하지만, 동작의 단위가 테스트 되어야 한다
      동작 단위는 여러 클래스에 걸칠 수도 있으며, 아주 작은 메서드 일 수도 있다
    - 좋은 입자성을 목표로 하는것은 도움이 안된다
      너무 작은 것을 목표로 하다보면 단위 테스트 결과가 훼손 될 수 있다\
      **=> 일반 사람들에게 응집도가 높고 의미가 있어야 한다**
      - 강아지를 부르면 오는것만 알면 되지 관절을 움직이는 걸 알 필요가 없다
        오히려 그런 작은 움직임에 주목하다보면 크게 어떤 동작인지 이해할 수 없다
- **의존성 그래프가 복잡한 클래스를 쉽게 테스트 가능하다**
  - 모든 협력자를 테스트 대역으로 대체하기 때문에 테스트 작성시 걱정할 필요가 없다
  - 단위 테스트에서 준비해야 할 작업량을 크게 줄일 수 있다
  - **하지만 의존성 그래프가 복잡한 클래스를 테스트할 방법을 찾는것이 아닌**
    **이러한 클래스를 갖지 않게 설계하는데 집중해야 한다**
    - 목을 사용하는 것은 이 문제를 감출 수는 있지만, 원인을 해결하지는 못한다

- **버그의 위치를 정확히 찾아낼 수 있다**
  - 협력자가 없으면 테스트 SUT (System Under Test) 외에 다른 것을 의심할 여지가 없다
  - 고전적 방식이면 의존하는 클래스에서 발생한 오류로도 테스트가 실패할 수 있다
    - 그렇기에 문제의 원인을 찾기가 더 여려워진다
    - 우려할 만한 사항이지만, 테스트를 정기적으로 실행하면 원인을 찾기 쉽다
      (마지막으로 수정한 사항으로 인해 오류가 발생할 것이니까)
    - 또한 하나를 고치면 자동으로 다른것들도 자동으로 고쳐질 수 있다
    - 테스트 스위트 전체에 계단식으로 실패하는데 가치가 있다
      결국, 고장 난 코드 조각이 큰 가치가 있다는 정보를 얻을 수 있기 때문이다



**런던파와 고전파의 차이점**

- **테스트 주도 개발을 통한 시스템 설계 방식**
  - **런던파**
    - 하향식 TDD (Out - In)
    - 목을 사용하여 협력자의 예상 결과를 설정하여, 해당 협력자의 구현을 미룰 수 있다
  - **고전파**
    - 일반적으로 상향식 TDD (In - Out)
    - 실제 객체를 다뤄야 하기 때문에 지침을 똑같이 둘 수 없다
- **과도한 명세 문제**
  - 런던 스타일은 고전 스타일보다 테스트가 구현에 더 자주 결합되는 편이다
    이로 인해 런던 스타일과 목의 남용에 대해서 이의가 제기된다



### 두 분파의 통합 테스트

격리 문제에 대한 견해 차이가 발생하여 통합 테스트 정의에도 차이가 존재

- **런던파**
  - 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주
    (고전 스타일 대부분의 테스트가 런던파 입장에서는 통합 테스트로 느껴질 수 있음)

- **고전파**
  - 단위 테스트의 특성을 하나라도 충족하지 않는 테스트
    - **예시**
      - 외부 의존성으로 인해 느린 테스트
        ('빠르게 수행' 위반)
      - 둘 이상의 동작 단위를 검증하는 테스트
        ('단일 동작 단위 검증' 위반)
      - 조직 내 다른 팀이 개발한 모듈과 함께 검증
        ('단일 동작 단위 검증' 위반)

**엔드 투 엔드 테스트**

- 통합 테스트의 일부, 통합 테스트보다 의존성을 더 많이 포함한다
  통합 테스트는 외부 의존성 한두개만 갖지만, 엔드 투 엔드 테스트는 의존성 대다수를 갖고 동작한다
- 데이터베이스, 파일 시스템, 결제 게이트웨이 라는 세가지 외부 의존성이 있는 경우

  - 통합 테스트

    - 데이터베이스, 파일 시스템만 포함하고 결제 게이트웨이는 대역으로 대체
      (자동으로 설정하기 쉬운 의존성만)
- **엔드 투 엔드 테스트**
  
  - 외부 의존성을 대부분 포함
    - 유지 보수 측면에서 비용이 많이 들어 모든 단위/통합 테스트 통과 후
    빌드 프로세스 후반에 실행하는 것이 좋다
    - 일부 의존성 테스트 버전이 없거나 의존성을 필요한 상태로 가져오는게 불가능 해서
      테스트 대역을 사용해야 할 수도 있다\
    **=> 통합테스트와 엔드 투 엔드 테스트에 뚜렷한 경계는 없다**



# 3. 단위 테스트 구조

## 단위 테스트를 구성하는 방법

### AAA 패턴

테스트를 준비, 실행, 검증이라는 세 부분을 나눈다
단순하고 균일한 구조를 가져서서 일관성이 있으며 가독성이 좋다



### 여러 개의 준비, 실행, 검증 구절 피하기

여러개의 준비, 실행, 검증 구절이 있다
=> 단일 동작을 검증하는 것이 아니다, 즉 더 이상 단위 테스트의 영역이 아니다
      따라서 이러한 테스트 구조는 피하는 것이 좋다



### 테스트 내 if문 피하기

if문이 있으면 유지비가 불어나고 가독성이 떨어진다.
또한 한번에 너무 많은 것을 검증한다고 볼 수도 있다.

따라서 if 문이 있는 단위 테스트는 안티 패턴으로 피하는 것이 좋다.



### 각 구절은 얼마나 커야 하는가?

일반적으로 준비 구절이 가장 크다. 너무 커지면 별도의 팩토리 클래스로 도출하는 것이 좋다.

**실행 구절이 한 줄 이상인 경우를 경계하라**

- 클라이언트 코드에 의존 하는 등, 공개 API에 문제가 있을 경우가 있다.
  - 예시
    - 물건을 구매하는데 구매 확정과 재고 감소 메서드가 분리되어 있는 경우
      => 클라이언트가 두 번째 메서드를 호출하는 것에 의존하고 있다.
            호출 하지 않는 경우에 모순이 발생하는 잠재적 모순에 노출되어 있다.
            **캡슐화를 통해 불변성을 보장해줘야 한다.**
            (두 동작을 묶은 메서드만 노출, 나머지는 감출 것)



### 검증 구절에는 검증문이 얼마나 있어야 하는가

단위 테스트는 동작의 단위기 때문에 여러 결과를 낼 수도 있다.
하지만 검증 구절이 너무 커지는 것은 경계해야 한다.
제품 코드에서 추상화가 누럭됐을 수도 있다.



### 종료 단계는 어떤가

테스트에 의해 작성된 파일 지우기, 데이터베이스 연결 종료 등이 있다.
통합 테스트의 영역이다.



### 테스트 대상 시스템 구별하기

단위 테스트가 검증하는 동작은 여러 클래스에 걸칠만큼 클 수도 있다.
그럼에도 진입점은 하나만 존재하는데 이 진입점을 SUT가 제공하는 것이다.
(동작을 수행할 하나의 클래스)

테스트 내에서 SUT를 찾는데 시간을 많이 들일 필요가 없으므로 sut로 명명해라



## 테스트 간 테스트 픽스처 재사용

준비 구절의 코드를 재사용하면 테스트를 줄이면서 단순화 하기 좋다.
그러기 위해 준비 구절을 별도의 메서드나 클래스로 도출할 수 있다.

**테스트 픽스처** : SUT로 전달되는 인수다.

**장점**

- 테스트 코드의 양을 줄일 수 있다

**단점**

- 테스트 간 결합도가 높아진다
- 테스트 가독성이 떨어진다



### 테스트 간의 높은 결합도는 안티 패턴이다

테스트의 준비 로직을 수행하면 모든 테스트에 영향을 미친다.
테스트를 수정해도 다른 테스트에 영향을 주면 안되기에 테스트간에 공유 상태를 두지 말아야 한다



### 테스트 가독성을 떨어뜨리는 생성자 사용

준비 코드를 생성자로 추출하면 가독성이 떨어진다.
테스트만 보고는 더 이상 전체 그림을 볼 수 없다.
준비 로직이 별로 없더라도 테스트 메서드로 바로 옮기는 것이 좋다.



### 더 나은 테스트 픽스처 재사용법

테스트 클래스에 비공개 펙터리 메서드를 두어 테스트 픽스처를 재사용할 수 있다.

**장점**

- 테스트 코드를 짧게 한다
- 가독성이 좋으며 전체 맥락을 유지할 수 있다
- 테스트가 서로 결합되지 않는다
- 재사용성이 좋다

**예외**

- 모든 테스트에서 사용하는 데이터베이스와의 연결 부분은
  생성자에서 데이터베이스 연결을 초기화 하는것이 더 합리적이다



## 단위 테스트 명명법

단위 테스트에 표현력 있는 이름을 붙이면 검증하는 내용과 기본 시스템의 동작을 이해하는 데 도움이 된다.

**엄격한 명명 구조에 얽매이지 않고 간단하고 쉬운 영어 구문이 훨씬 효과적이다.**
간단한 문구로 고객이나 도메인 전문가에게 의미 있는 방식으로 시스템 동작을 설명할 수 있어야 한다.



### 단위 테스트 명명 지침

- 엄격한 명명 정책을 따르지 않는다. 표현의 자유를 허용하자
- 도메인 전문가나 비즈니스 분석가에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자
- 단어를 밑줄 표시로 구분하여 가독성을 향상시키자



### 예시

아래와 같은 엄격한 명명 정책 보다

```java
isDeliveryValid_InvalidDate_ReturnsFalse();
```

이러한 유여한 표현이 훨씬 가독성이 좋다.

```java
delivery_with_a_past_date_is_invalid();
```



## 매개변수화된 테스트 리팩터링하기

테스트 하나로는 동작 단위를 완전하게 설명하기 어려울 수 있다.
단위 테스트 프레임워크의 매개변수화된 테스트를 사용하면 테스트를 여러개로 만들지 않고
유사한 테스트를 묶을 수 있다.

**장점**

- 테스트 코드의 양을 줄일 수 있다

**단점**

- 테스트 메서드가 나타내는 사실을 파악하기 어려워진다
- 매개변수가 많을수록 더 어렵다

긍정적인 테스트케이스와 부정적인 테스트케이스를 하나의 메서드로 둘 수 있으며 좋으나
불가능한 경우에는 긍정적인 테스트 케이스를 도출하라.

동작이 복잡하면 매개변수화된 테스트를 사용하지 마라. 

[예시](https://github.com/devMuscle/TIL/commit/164dfc181d2a51c11dd2828e891c257447e2965a)



## 검증문 라이브러리를 사용한 테스트 가독성 향상

Junit에서 기본적으로 제공하는 Jupiter를 사용할 수도 있지만,
AssertJ, Hemcrest 같은 라이브러리를 사용할 수도 있다.

**장점**

- 이야기 처럼 읽을 수 있는 방식으로 코드를 구성하여 가독성을 높일 수 있다

**단점**

- 의존성을 추가해야 한다



## 도서

- [단위 테스트](https://product.kyobobook.co.kr/detail/S000001805070)

