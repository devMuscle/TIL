# Unit Testing

## 단위 테스트의 목표

### 단위 테스트의 목표

- 단위 테스트가 더 나은 설계로 이어질 수는 있지만, 이는 부수적 효과이며 주 목표는 아니다
- 단위 테스트의 목표는 **소프트웨어 프로젝트의 지속가능한 성장을 가능하게 하는 것**이다



### 코드 커버리지 (Code Coverage, Test Coverage)

- **코드 커버리지 (테스트 커버리지) = 제품 코드 라인 수 / 전체 라인 수**

- 커버리지 지표는 괜찮은 부정 지표이지만 좋은 긍정 지표는 아니다

  - 코드 커버리지가 낮으면 테스트가 충분치 않다는 좋은 증거지만
    코드 커버리지가 높다고 양질의 테스트코드라는 것은 보장하지 않는다

  - [예시](https://github.com/devMuscle/TIL/blob/main/unit-testing/unit-testing/src/test/java/me/devMuscle/unittesting/TestCoverageTest.java)

    - isStringLong1 의 경우 코드 커버리지가 80% 이지만
      isStringLong2 의 경우 코드 커버리지가 100% 이다

    - 테스트 스위트를 개선하지 않았지만 커버리지 숫자가 변화 하였다

      

### 분기 커버리지 (Branch Coverage)

- 분기 커버리지는 코드 커버리지의 단점을 극복하는데 도움이 되어, 더 정확한 결과를 제공한다
- **분기 커버리지 = 통과 분기 / 전체 분기 수**



### 커버리지 지표에 대한 문제점

- **테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다**

  - 테스트 대상 시스템이 낸 결과가 정확히 예상되는 결과인지 확인해야 한다
  - 결과가 여러개 일 수 있다
  - 지표가 의미 있으려면, 모든 측정 지표를 검증해야 한다
  - [예시](https://github.com/devMuscle/TIL/blob/main/unit-testing/unit-testing/src/test/java/me/devMuscle/unittesting/TestCoverageTest.java)
    - isStringLong 메서드에 대한 테스트에서 return 값에 대한 검증만 하지
      wasLastStringLong 에 대입하는 결과에 대해서는 검증하지 않는다
    - 검증이 없는 테스트의 경우 언제나 통과한다

- **외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다**

  - 분기 커버리지 지표가 100%로 표시되며, 메서드 결과의 모든 구성 요소를 검증하지만 테스트가 완벽하지 않다
  - [예시](https://github.com/devMuscle/TIL/blob/main/unit-testing/unit-testing/src/test/java/me/devMuscle/unittesting/TestCoverageTest.java)
    - Interger.parseInt 를 수행시에 입력 매개변수에 따라 숨어있는 분기가 많다
      - Null 값
      - 빈 문자열
      - 정수가 아님
      - 너무 긴 문자열

  - 수많은 예외상황에 빠질 수 있지만, 테스트에서 모든 예외 상황을 다루는지 확인할 방법이 없다
  - 모든 코드 경로를 고려해야하는 것이 아니라
    해당 지표로는 단위 테스트가 얼마나 좋은지/나쁜지 판단할 수 없다는 것을 보여준다



### 무엇이 성공적인 테스트 스위트를 만드는가?

- 테스트 스위트가 얼마나 좋은지는 자동으로 확인할 수 없다.
  개인의 판단에 맡겨야 한다.
- 성공적인 테스트 스위트의 특성
  - **개발 주기에 통합되어 있다**
    - 이상적으로는 코드가 변경될때 마다 아무리 작은것이라도 테스트를 실행해야 한다
  - **코드베이스에서 가장 중요한 부분만을 대상으로 한다**
    - 시스템의 가장 중요한 부분에 대한 테스트 노력을 기울이고,
      다른 부분은 간략하게 또는 간접적으로 검증하는 것이 좋다
  - **최소한의 유지비로 최대의 가치를 이끌어낸다**
    - 가치가 유지비를 상회하는 테스트만 스위트에 유지하는 것이 중요하다



## 단위 테스트란 무엇인가

### '단위 테스트'의 정의

- **단위 테스트의 중요한 세가지 속성**
  - 작은 코드 조각 (단위라고도 함)을 검증하고
  - 빠르게 수행하고
  - 격리된 방식으로 처리하는 자동화된 테스트다

- **격리 문제에 대한 접근 차이**

  - **런던파**

    - 테스트 대상 시스템에서 협력자를 격리하는것으로 본다

      **협력자** : 공유가능하거나 변경 가능한 의존성

    - 모든 의존성을 테스트 대역(Test Double)로 대체한다

    - 외부 영향과 분리하여 테스트 대상에만 집중

    - **장점**

      - 의존성과 별개로 단위테스트 수행 가능
      - 테스트가 실패하면 어느 부분이 고장났는지 확실히 알 수 있다

  - **고전파**

    - 단위 테스트 끼리만 격리 (코드 끼리는 격리 안해도 된다)

- **의존성**

  - **공유 의존성**

    - 테스트간에 공유되고 서로 결과에 영향을 줄 수 있는 의존성
    - static 필드나 데이터베이스 같은 경우
    - **테스트 실행 속도를 높이기 위해 대체 하기도 함**
      - 거의 실행 프로세스 외부에 존재하여 시간이 오래 걸린다.
        단위 테스트의 두 번째 속성으로 빨리 실행해야 하는 필요성이 있다.
  - **비공개 의존성**
  
    - 공유하지 않는 의존성
  - **외부 의존성**

    - 애플리케이션 실행 프로세스 외부의 의존성
    - 데이터베이스 같은 경우
    - 외부 의존성이지만 공유 의존성은 아닐 수 있다
      - 각 테스트 실행 전에 데이터베이스를 도커 컨테이너로 시작
      - 외부 읽기 전용 API (수정할 수 없는 경우)
  - **휘발성 의존성**
    - 런타임 환경의 설정 및 구성을 요구
    
      - 데이터베이스,  API 서비스
    
    - 비결정적 동작을 포함
    
      - 각 호출에 대한 다른 결과 반환
    
      - 난수 생성기, 현재 날짜 계산기
    



### 단위 테스트의 런던파와 고전파

- **의견 차이가 생기는 지점**

  - 격리 요구 사항
  - 테스트 대상 조각(단위)의 구성 요소
  - 의존성 처리

  |            |  격리 주체  |         단위의 크기          |   테스트 대역 사용 대상    |
  | ---------- | :---------: | :--------------------------: | :------------------------: |
  | **런던파** |    단위     |         단일 클래스          | 불변 의존성 외 모든 의존성 |
  | **고전파** | 단위 테스트 | 단일 클래스 또는 클래스 세트 |        공유 의존성         |

  - [예시](https://github.com/devMuscle/TIL/tree/main/unit-testing/unit-testing/src/test/java/me/devMuscle/unittesting/chapter2)
    - Customer는 Product와 Store에 의존중인데
      - [런던파](https://github.com/devMuscle/TIL/blob/main/unit-testing/unit-testing/src/test/java/me/devMuscle/unittesting/chapter2/LondonStyleTest.java)의 경우 비공유 의존성인 Store가 불변 의존성이 아니기에 테스트 대역으로 대체 하였다.
        (Product는 enum이기에 불변하는 값 객체이지만 Store의 경우 내부 상태가 변경될 가능성은 있다)
      - [고전파](https://github.com/devMuscle/TIL/blob/main/unit-testing/unit-testing/src/test/java/me/devMuscle/unittesting/chapter2/TraditionalStyleTest.java)의 경우 둘 다 비공유 의존성이기에 테스트 대역으로 대체하지 않고 실제 객체를 사용하였다.

- **의존성을 다루는 방법**

  - **런던파**
    - 불변 객체는 테스트 대역으로 교체하지 않는다
      (위의 예시의 경우 Product에 해당)
    - 변경 가능한 비공개 의존성은 테스트 대역으로 교체한다
      (위의 예시의 경우 Store에 해당)
  - **고전파**
    - 공유 의존성을 테스트 대역으로 교체한다
  
  

### 고전파 vs 런던파 비교

**런던파의 장점**

- **한 번에 한 클래스만 테스트 가능하다**
  - 입자성 (granularity) 가 좋다, 테스트가 세밀해서 (fine-grained) 한 번에 한 클래스만 확인한다
  - **단위 테스트의 단위**
    - 런던파는 클래스를 단위로 간주하지만, 동작의 단위가 테스트 되어야 한다
      동작 단위는 여러 클래스에 걸칠 수도 있으며, 아주 작은 메서드 일 수도 있다
    - 좋은 입자성을 목표로 하는것은 도움이 안된다
      너무 작은 것을 목표로 하다보면 단위 테스트 결과가 훼손 될 수 있다
      **=> 일반 사람들에게 응집도가 높고 의미가 있어야 한다**
      - 강아지를 부르면 오는것만 알면 되지 관절을 움직이는 걸 알 필요가 없다
        오히려 그런 작은 움직임에 주목하다보면 크게 어떤 동작인지 이해할 수 없다
- **의존성 그래프가 복잡한 클래스를 쉽게 테스트 가능하다**
  - 모든 협력자를 테스트 대역으로 대체하기 때문에 테스트 작성시 걱정할 필요가 없다
  - 단위 테스트에서 준비해야 할 작업량을 크게 줄일 수 있다
  - **하지만 의존성 그래프가 복잡한 클래스를 테스트할 방법을 찾는것이 아닌**
    **이러한 클래스를 갖지 않게 설계하는데 집중해야 한다**
    - 목을 사용하는 것은 이 문제를 감출 수는 있지만, 원인을 해결하지는 못한다

- **버그의 위치를 정확히 찾아낼 수 있다**
  - 협력자가 없으면 테스트 SUT (System Under Test) 외에 다른 것을 의심할 여지가 없다
  - 고전적 방식이면 의존하는 클래스에서 발생한 오류로도 테스트가 실패할 수 있다
    - 그렇기에 문제의 원인을 찾기가 더 여려워진다
    - 우려할 만한 사항이지만, 테스트를 정기적으로 실행하면 원인을 찾기 쉽다
      (마지막으로 수정한 사항으로 인해 오류가 발생할 것이니까)
    - 또한 하나를 고치면 자동으로 다른것들도 자동으로 고쳐질 수 있다
    - 테스트 스위트 전체에 계단식으로 실패하는데 가치가 있다
      결국, 고장 난 코드 조각이 큰 가치가 있다는 정보를 얻을 수 있기 때문이다



**런던파와 고전파의 차이점**

- **테스트 주도 개발을 통한 시스템 설계 방식**
  - **런던파**
    - 하향식 TDD (Out - In)
    - 목을 사용하여 협력자의 예상 결과를 설정하여, 해당 협력자의 구현을 미룰 수 있다
  - **고전파**
    - 일반적으로 상향식 TDD (In - Out)
    - 실제 객체를 다뤄야 하기 때문에 지침을 똑같이 둘 수 없다
- **과도한 명세 문제**
  - 런던 스타일은 고전 스타일보다 테스트가 구현에 더 자주 결합되는 편이다
    이로 인해 런던 스타일과 목의 남용에 대해서 이의가 제기된다



### 두 분파의 통합 테스트

격리 문제에 대한 견해 차이가 발생하여 통합 테스트 정의에도 차이가 존재

- **런던파**
  - 실제 협력자 객체를 사용하는 모든 테스트를 통합 테스트로 간주
    (고전 스타일 대부분의 테스트가 런던파 입장에서는 통합 테스트로 느껴질 수 있음)

- **고전파**
  - 단위 테스트의 특성을 하나라도 충족하지 않는 테스트
    - **예시**
      - 외부 의존성으로 인해 느린 테스트
        ('빠르게 수행' 위반)
      - 둘 이상의 동작 단위를 검증하는 테스트
        ('단일 동작 단위 검증' 위반)
      - 조직 내 다른 팀이 개발한 모듈과 함께 검증
        ('단일 동작 단위 검증' 위반)

**엔드 투 엔드 테스트**

- 통합 테스트의 일부, 통합 테스트보다 의존성을 더 많이 포함한다
  통합 테스트는 외부 의존성 한두개만 갖지만, 엔드 투 엔드 테스트는 의존성 대다수를 갖고 동작한다

- 데이터베이스, 파일 시스템, 결제 게이트웨이 라는 세가지 외부 의존성이 있는 경우

  - 통합 테스트

    - 데이터베이스, 파일 시스템만 포함하고 결제 게이트웨이는 대역으로 대체
      (자동으로 설정하기 쉬운 의존성만)

  - **엔드 투 엔드 테스트**

    - 외부 의존성을 대부분 포함

    - 유지 보수 측면에서 비용이 많이 들어 모든 단위/통합 테스트 통과 후
      빌드 프로세스 후반에 실행하는 것이 좋다

    - 일부 의존성 테스트 버전이 없거나 의존성을 필요한 상태로 가져오는게 불가능 해서
      테스트 대역을 사용해야 할 수도 있다
      **=> 통합테스트와 엔드 투 엔드 테스트에 뚜렷한 경계는 없다**

      

## 도서

- [단위 테스트](https://product.kyobobook.co.kr/detail/S000001805070)

