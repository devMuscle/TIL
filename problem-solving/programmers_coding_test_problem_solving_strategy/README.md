# 프로그래머스 코딩 테스트 문제 풀이 전략: 자바편

[링크](https://product.kyobobook.co.kr/detail/S000200928002)

# Chapter1. 코딩 테스트

## 1. 전화번호 나타내기

String의 replaceAll 메서드와 정규식을 사용하여 문자열 형태 통일하기



## 2. 전화번호부의 사람 나타내기

전화번호를 다량 보유한 사람을 List 자료구조로 관리하기



## 3. 사람과 전화번호 비교하기

전화번호 기반으로 사람을 비교하기 위해 List의 contains 메서드를 활용
이때 contains는 equals 메서드를 기반으로 동작하기에 객체가 아닌 전화번호를 기반으로 비교하기 위해 equals 메서드 오버라이딩



## 4. 전화번호부 나타내기

동일한 객체의 중복을 방지하기 위해 List가 아닌 Set 자료구조 채택

전화번호부에서 해당 전화번호를 가지고있는 사람을 찾기위해 stream().filter() 사용 



# Chapter 4. 문자열

## 1. 문자열이란

### 문자의 배열

문자열 String은 내부적으로 문자의 배열을 이용해서 표현
다음과 같은 방법으로 문자에 접근 가능

- ```String.charAt(int index)```
- ```String.toCharArray()```



### 아스키코드

문자는 내부적으로 정수로 취급되고 연산된다.
정수와 문자를 바꾸는 규칙으로 아스키 코드를 사용한다.



### StringBuilder

```String```은 문자열을 수정할때 마다 새로운 문자열을 만들기 때문에 시간, 공간적으로 효율적이지 못하다.
```StringBuilder```는 수정할때마다 내부 배열에서 직접 수정한다.



# Chapter 5. 재귀

## 1. 재귀란?

재귀는 메서드 호출을 이요한 방법으로, 하나의 메서드 내에서 자기 자신을 호출하도록 하여 반복적인 개념을 구현하는 것이다.
하나의 재귀 호출은 하나의 부분 문제를 해결한다.



### for문에서 벗어나기

같은 로직을 이용한 반복작업은 반복문을 이용해서 해결할 수 있다.
하지만 배열에서 n개의 원소를 합치는 작업을 반복문으로 해결할려고 하면 n중 반복문을 만들게 될 수도 있는 것이다.



### 재귀의 최대 범위와 한계점 기억하기

재귀 호출은 반복 작업을 구현하는 것이기에 재귀의 호출 횟수가 시간 복잡도에 직접적으로 영향을 끼친다.
그래서 재귀 호출이 얼마나 수행되는지와 한 번 호출했을 때 어떤 작업을 하는지 잘 따져야 한다.

재귀 호출의 깊이도 주의 깊게 살펴 보아야 한다.
재귀 호출된 메서드에서 사용하는 변수들은 메모리에 추가 할당된다.
이 변수들은 재구 호출이 종료되어야 메모리에서 할당이 해제된다.

재귀 호출이 너무 깊게 들어가버리면 변수들이 메모리를 모두 할당해서 **StackOverFlow** 예외가 발생한다.
이것을 방지하기 위해서는 재귀 호출의 깊이를 **10,000 이하** 아무리 많아도 20,000 이하로 유지해야 한다.



## 2. 재귀 정의하기

### 상태 정의하기

재귀는 **부분 문제**를 해결해 나가는 풀이 방법이다.
부분 문제는 각각 하나의 명확한 문제를 나타내어 하나의 답을 낼 수 있어야 한다.
답을 내는 데 입력되는 변수들이 필요하고, 이렇게 답을 결정하는 변수들을 **상태**라고 한다.
그리고 부분 문제는 하나의 상태에 대한 답을 찾는 문제가 된다.



### 종료 조건

부분 문제는 상태에 대한 답을 찾는 것이므로 부분 문제가 나타내는 상태가 재귀가 진행될수록 점점 작아져,
결국 이어지는 부분 문제 없이 즉시 답이 나와야 한다.
이렇게 즉시 답이 나오는 상태를 검사하여 답을 반환할 수 있도록 하는 것을 **종료 조건**이라고 하고,
종료 조건에 도달할 수 있도록 부분 문제로 상태가 변해 가는 것을 **상태가 작아진다**고 한다.



### 점화식

부분 문제는 같은 규칙으로 더 작은 부분 문제로 진행되어야 한다.
따라서 상태 또한 하나의 규칙으로 더작은 상태로 전이되어야 한다.
이렇게 **상태를 전이시키는 규칙을 점화식**이라고 한다.



# 완전 탐색

## 완전 탐색이란?

완전 탐색은 문제에서 제시하는 조건을 만족하는 모든 경우를 확인하면서 정답을 찾는 탐색이다.
이 방식은 구현만 제대로 한다면 가능한 모든 경우를 빠짐없이 확인하기 때문에 무조건 정답을 찾을 수 있는 정확성이 높은 탐색이다.
완전 탐색을 이용해서 문제를 해결할때 필수적으로 시간 복잡도를 확인해야 하는데,
시간 복잡도가 충분히 작다면 완전 탐색을 적용하는 것이 가장 나을 수 있다.



### 상태와 상태 전이 진행

완전 탐색에서는 탐색을 진행하면서 상태를 전이시켜 나간다.
완전 탐색의 상태에는 탐색의 진행 상태를 표현할 수 있는 변수들이 포함되고,
하나의 상태를 이용해서 다음 상태를 만들어 나가는상태 전이를 통해 탐색을 진행한다.



### 완전 탐색의 종류

완전 탐색은 가능한 모든 경우를 검사하는 탐색으로 문제 조건에 따라 구현하는 방법이 달라진다.



**간단히 구현되는 완전 탐색**

난이도가 낮은 문제는 간단한 완전 탐색으로 해결될 때가 있다.
이 경우 특별한 구현 없이 중첩 for 문 정도로 완전 탐색을 구현할 수 있다.



**깊이 우선 탐색**

깊이 우선 탐색(Depth First Search, DFS) 는 재귀로 쉽게 구현할 수 있는 완전 탐색 방법이다.
재귀로 구현되기 때문에 상태 전이를 여러 방법으로 할 수 있다면
하나의 전이 방법을 더 이상 불가능할 때까지 연속적으로 적용한다는 특징이 있다.



**너비 우선 탐색**

너비 우선 탐색(Breadth First Search, BFS)은  자료 구조인 큐를 이용하여 구현되는 완전 탐색 방법이다.
너비 우선 탐색은 깊이 우선 탐색과는 다르게 하나의 상태에서 전이되는 다음 단계의 상태들을 방문한 후 그 다음 상태들을 방문한다.



### 방문 처리

완전 탐색의 시간 복잡도는 탐색해야 할 상태 개수, 즉 탐색 공간의 크기에 비례한다.
이렇게 탐색 공간의 크기를 이용하여 완전 탐색의 시간 복잡도를 계산할 때는 한 번 방문한 상태를  재방문해서는 안 된다.
중복으로 탐색하는 공간이 클 수록 더 큰 시간 복잡도를 낳게 되기에 방지를 위해 방문 처리를 해야한다.
