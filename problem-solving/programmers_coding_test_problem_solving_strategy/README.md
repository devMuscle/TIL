# 프로그래머스 코딩 테스트 문제 풀이 전략: 자바편

[링크](https://product.kyobobook.co.kr/detail/S000200928002)

# Chapter1. 코딩 테스트

## 1. 전화번호 나타내기

String의 replaceAll 메서드와 정규식을 사용하여 문자열 형태 통일하기



## 2. 전화번호부의 사람 나타내기

전화번호를 다량 보유한 사람을 List 자료구조로 관리하기



## 3. 사람과 전화번호 비교하기

전화번호 기반으로 사람을 비교하기 위해 List의 contains 메서드를 활용
이때 contains는 equals 메서드를 기반으로 동작하기에 객체가 아닌 전화번호를 기반으로 비교하기 위해 equals 메서드 오버라이딩



## 4. 전화번호부 나타내기

동일한 객체의 중복을 방지하기 위해 List가 아닌 Set 자료구조 채택

전화번호부에서 해당 전화번호를 가지고있는 사람을 찾기위해 stream().filter() 사용 



# Chapter 4. 문자열

## 1. 문자열이란

### 문자의 배열

문자열 String은 내부적으로 문자의 배열을 이용해서 표현
다음과 같은 방법으로 문자에 접근 가능

- ```String.charAt(int index)```
- ```String.toCharArray()```



### 아스키코드

문자는 내부적으로 정수로 취급되고 연산된다.
정수와 문자를 바꾸는 규칙으로 아스키 코드를 사용한다.



### StringBuilder

```String```은 문자열을 수정할때 마다 새로운 문자열을 만들기 때문에 시간, 공간적으로 효율적이지 못하다.
```StringBuilder```는 수정할때마다 내부 배열에서 직접 수정한다.



# Chapter 5. 재귀

## 1. 재귀란?

재귀는 메서드 호출을 이요한 방법으로, 하나의 메서드 내에서 자기 자신을 호출하도록 하여 반복적인 개념을 구현하는 것이다.
하나의 재귀 호출은 하나의 부분 문제를 해결한다.



### for문에서 벗어나기

같은 로직을 이용한 반복작업은 반복문을 이용해서 해결할 수 있다.
하지만 배열에서 n개의 원소를 합치는 작업을 반복문으로 해결할려고 하면 n중 반복문을 만들게 될 수도 있는 것이다.



### 재귀의 최대 범위와 한계점 기억하기

재귀 호출은 반복 작업을 구현하는 것이기에 재귀의 호출 횟수가 시간 복잡도에 직접적으로 영향을 끼친다.
그래서 재귀 호출이 얼마나 수행되는지와 한 번 호출했을 때 어떤 작업을 하는지 잘 따져야 한다.

재귀 호출의 깊이도 주의 깊게 살펴 보아야 한다.
재귀 호출된 메서드에서 사용하는 변수들은 메모리에 추가 할당된다.
이 변수들은 재구 호출이 종료되어야 메모리에서 할당이 해제된다.

재귀 호출이 너무 깊게 들어가버리면 변수들이 메모리를 모두 할당해서 **StackOverFlow** 예외가 발생한다.
이것을 방지하기 위해서는 재귀 호출의 깊이를 **10,000 이하** 아무리 많아도 20,000 이하로 유지해야 한다.



## 2. 재귀 정의하기

### 상태 정의하기

재귀는 **부분 문제**를 해결해 나가는 풀이 방법이다.
부분 문제는 각각 하나의 명확한 문제를 나타내어 하나의 답을 낼 수 있어야 한다.
답을 내는 데 입력되는 변수들이 필요하고, 이렇게 답을 결정하는 변수들을 **상태**라고 한다.
그리고 부분 문제는 하나의 상태에 대한 답을 찾는 문제가 된다.



### 종료 조건

부분 문제는 상태에 대한 답을 찾는 것이므로 부분 문제가 나타내는 상태가 재귀가 진행될수록 점점 작아져,
결국 이어지는 부분 문제 없이 즉시 답이 나와야 한다.
이렇게 즉시 답이 나오는 상태를 검사하여 답을 반환할 수 있도록 하는 것을 **종료 조건**이라고 하고,
종료 조건에 도달할 수 있도록 부분 문제로 상태가 변해 가는 것을 **상태가 작아진다**고 한다.



### 점화식

부분 문제는 같은 규칙으로 더 작은 부분 문제로 진행되어야 한다.
따라서 상태 또한 하나의 규칙으로 더작은 상태로 전이되어야 한다.
이렇게 **상태를 전이시키는 규칙을 점화식**이라고 한다.
