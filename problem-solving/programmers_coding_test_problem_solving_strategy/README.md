# 프로그래머스 코딩 테스트 문제 풀이 전략: 자바편

[링크](https://product.kyobobook.co.kr/detail/S000200928002)

# Chapter1. 코딩 테스트

## 1. 전화번호 나타내기

String의 replaceAll 메서드와 정규식을 사용하여 문자열 형태 통일하기



## 2. 전화번호부의 사람 나타내기

전화번호를 다량 보유한 사람을 List 자료구조로 관리하기



## 3. 사람과 전화번호 비교하기

전화번호 기반으로 사람을 비교하기 위해 List의 contains 메서드를 활용
이때 contains는 equals 메서드를 기반으로 동작하기에 객체가 아닌 전화번호를 기반으로 비교하기 위해 equals 메서드 오버라이딩



## 4. 전화번호부 나타내기

동일한 객체의 중복을 방지하기 위해 List가 아닌 Set 자료구조 채택

전화번호부에서 해당 전화번호를 가지고있는 사람을 찾기위해 stream().filter() 사용 



# Chapter 4. 문자열

## 1. 문자열이란

### 문자의 배열

문자열 String은 내부적으로 문자의 배열을 이용해서 표현
다음과 같은 방법으로 문자에 접근 가능

- ```String.charAt(int index)```
- ```String.toCharArray()```



### 아스키코드

문자는 내부적으로 정수로 취급되고 연산된다.
정수와 문자를 바꾸는 규칙으로 아스키 코드를 사용한다.



### StringBuilder

```String```은 문자열을 수정할때 마다 새로운 문자열을 만들기 때문에 시간, 공간적으로 효율적이지 못하다.
```StringBuilder```는 수정할때마다 내부 배열에서 직접 수정한다.



# Chapter 5. 재귀

## 1. 재귀란?

재귀는 메서드 호출을 이요한 방법으로, 하나의 메서드 내에서 자기 자신을 호출하도록 하여 반복적인 개념을 구현하는 것이다.
하나의 재귀 호출은 하나의 부분 문제를 해결한다.



### for문에서 벗어나기

같은 로직을 이용한 반복작업은 반복문을 이용해서 해결할 수 있다.
하지만 배열에서 n개의 원소를 합치는 작업을 반복문으로 해결할려고 하면 n중 반복문을 만들게 될 수도 있는 것이다.



### 재귀의 최대 범위와 한계점 기억하기

재귀 호출은 반복 작업을 구현하는 것이기에 재귀의 호출 횟수가 시간 복잡도에 직접적으로 영향을 끼친다.
그래서 재귀 호출이 얼마나 수행되는지와 한 번 호출했을 때 어떤 작업을 하는지 잘 따져야 한다.

재귀 호출의 깊이도 주의 깊게 살펴 보아야 한다.
재귀 호출된 메서드에서 사용하는 변수들은 메모리에 추가 할당된다.
이 변수들은 재구 호출이 종료되어야 메모리에서 할당이 해제된다.

재귀 호출이 너무 깊게 들어가버리면 변수들이 메모리를 모두 할당해서 **StackOverFlow** 예외가 발생한다.
이것을 방지하기 위해서는 재귀 호출의 깊이를 **10,000 이하** 아무리 많아도 20,000 이하로 유지해야 한다.



## 2. 재귀 정의하기

### 상태 정의하기

재귀는 **부분 문제**를 해결해 나가는 풀이 방법이다.
부분 문제는 각각 하나의 명확한 문제를 나타내어 하나의 답을 낼 수 있어야 한다.
답을 내는 데 입력되는 변수들이 필요하고, 이렇게 답을 결정하는 변수들을 **상태**라고 한다.
그리고 부분 문제는 하나의 상태에 대한 답을 찾는 문제가 된다.



### 종료 조건

부분 문제는 상태에 대한 답을 찾는 것이므로 부분 문제가 나타내는 상태가 재귀가 진행될수록 점점 작아져,
결국 이어지는 부분 문제 없이 즉시 답이 나와야 한다.
이렇게 즉시 답이 나오는 상태를 검사하여 답을 반환할 수 있도록 하는 것을 **종료 조건**이라고 하고,
종료 조건에 도달할 수 있도록 부분 문제로 상태가 변해 가는 것을 **상태가 작아진다**고 한다.



### 점화식

부분 문제는 같은 규칙으로 더 작은 부분 문제로 진행되어야 한다.
따라서 상태 또한 하나의 규칙으로 더작은 상태로 전이되어야 한다.
이렇게 **상태를 전이시키는 규칙을 점화식**이라고 한다.



# Chapter 6. 완전 탐색

## 1. 완전 탐색이란?

완전 탐색은 문제에서 제시하는 조건을 만족하는 모든 경우를 확인하면서 정답을 찾는 탐색이다.
이 방식은 구현만 제대로 한다면 가능한 모든 경우를 빠짐없이 확인하기 때문에 무조건 정답을 찾을 수 있는 정확성이 높은 탐색이다.
완전 탐색을 이용해서 문제를 해결할때 필수적으로 시간 복잡도를 확인해야 하는데,
시간 복잡도가 충분히 작다면 완전 탐색을 적용하는 것이 가장 나을 수 있다.



### 상태와 상태 전이 진행

완전 탐색에서는 탐색을 진행하면서 상태를 전이시켜 나간다.
완전 탐색의 상태에는 탐색의 진행 상태를 표현할 수 있는 변수들이 포함되고,
하나의 상태를 이용해서 다음 상태를 만들어 나가는상태 전이를 통해 탐색을 진행한다.



### 완전 탐색의 종류

완전 탐색은 가능한 모든 경우를 검사하는 탐색으로 문제 조건에 따라 구현하는 방법이 달라진다.



**간단히 구현되는 완전 탐색**

난이도가 낮은 문제는 간단한 완전 탐색으로 해결될 때가 있다.
이 경우 특별한 구현 없이 중첩 for 문 정도로 완전 탐색을 구현할 수 있다.



**깊이 우선 탐색**

깊이 우선 탐색(Depth First Search, DFS) 는 재귀로 쉽게 구현할 수 있는 완전 탐색 방법이다.
재귀로 구현되기 때문에 상태 전이를 여러 방법으로 할 수 있다면
하나의 전이 방법을 더 이상 불가능할 때까지 연속적으로 적용한다는 특징이 있다.



**너비 우선 탐색**

너비 우선 탐색(Breadth First Search, BFS)은  자료 구조인 큐를 이용하여 구현되는 완전 탐색 방법이다.
너비 우선 탐색은 깊이 우선 탐색과는 다르게 하나의 상태에서 전이되는 다음 단계의 상태들을 방문한 후 그 다음 상태들을 방문한다.



### 방문 처리

완전 탐색의 시간 복잡도는 탐색해야 할 상태 개수, 즉 탐색 공간의 크기에 비례한다.
이렇게 탐색 공간의 크기를 이용하여 완전 탐색의 시간 복잡도를 계산할 때는 한 번 방문한 상태를  재방문해서는 안 된다.
중복으로 탐색하는 공간이 클 수록 더 큰 시간 복잡도를 낳게 되기에 방지를 위해 방문 처리를 해야한다.



# Chapter 7. 정렬

## 1. 정렬이란?

### 정렬 기준 잡기

하나의 데이터라도 포함된 데이터 종류에 따라 다양한 기준으로 정렬할 수 있다.
따라서 문제를 잘 파악하고 문제의 요구 사항에 맞게 정렬 기준을 잘 선택해야 한다.



### 정렬 효율 높이기

리스트를 순회하는데는 O(N) 의 시간복잡도가 소요되는데, 정렬은 O(N * logN) 이 소요된다.
데이터 구조와 문제 조건에 따라 데이터를 비교하는 방법과 시간 복잡도가 달라지므로
불필요한 비교와 정렬은 최소화하고 문제 조건을 맞출 수 있는 최소한의 정렬을 진행해야 한다.



## 2. 정렬하기

### 직접 기준 정하기

모든 문제를 기본 정렬 기준을 사용해서 해결할 수 있는 것은 아니다.
아름차순이 아닌 내림차순으로 정렬하거나, 클래스를 정렬해야 할 수도 있다.



**Comparator<T>** 사용하기

정렬 메서드들은 Comparator<T>를 매개변수로 받을 수 있다.
Comparator<T>는 compare 메서드를 가지는 자바의 제네릭 인터페이스다.



**Comparator<T>의 반환 값**

compare 메서드는 제네릭 타입 T의 객체를 받아 비교한다.

| 부호 |       비교 결과       |
| :--: | :-------------------: |
|  0   |    두 객체가 같다     |
| 양수 |  왼쪽 객체가 더 크다  |
| 음수 | 오른쪽 객체가 더 크다 |

v1 - v2 의 결과라고 생각하면 된다.



# Chapter 8. 이진 탐색

## 1. 이진 탐색이란?

이진 탐색은 업다운 게임과 같다.
찾고자 하는 정답이 포함된 범위 중 가운데를 검사하고, 정답과 비교하여 절반의 범위를 제외한다.



### 이진 탐색이 갖는 이점

선형 탐색은 O(N)의 시간 복잡도를 가진다. 이는 업다운 게임에서 1부터 N까지 차례대로 부르는 것과 같다.
이진 탐색은 O(logN)의 시간 복잡도를 가진다. 이는 선형 탐색보다 N이 크면 클수록 성능이 강력하다.



### 이진 탐색을 사용할 수 있는 조건

이진 탐색을 적용하려면 배열이나 리스트가 **정렬되어 있어야** 한다.
정렬된 상태이어야 대소 비교를 하여 정답이 없는 구간을 확실히 제외할 수 있다.



## 2. 탐색 효율 높이기

### 분할 정복

이진 탐색은 남은 밤위를 계속해서 반으로 나눈다.
이렇게 탐색 공간을 특정 기준에 따라 나누고, 나눈 각 탐색 공간에서 탐색을 이어 나가는 것을 분할 정복이라고 한다.



### 정렬 기준 정하기

이진 탐색을 진행하려면 배열이 정렬되어 있어야 하기에, 정렬 규칙을 찾아내어 이진 탐색을 적용해야 한다.



### 정렬 방식 선택하기

이진 탐색을 적용하려면 문제에서 요구하는 조건을 정확히 파악하고,
이에 따른 대소 비교를 구현하여 데이터를 정렬한 후 진행해야 한다.



### 정렬 규칙 찾기

이진 탐색은 정답 조건을 만족하는 값 중 **가장 큰 값** 혹은 **가장 작은 값**을 찾는데도 많이 사용된다.
이런 유형의 탐색을 파라메트릭 서치라고도 한다.

이런 값을 찾으려면 다음 고민을 해야 한다.

1. 범위 좁히기
2. 범위 표기법



**범위 좁히기**

정확한 값을 찾는 이진 탐색과 다르게 가장 큰 값이나 가장 작은 값을 찾는 이진 탐색에서는
검사한 값이 정답 조건을 만족한다고 하더라도 범위에 포함될 수 있다. 따라서 범위를 좁힐 때 이를 반영해야 한다.

- 만족하는 값 중 가장 큰 값을 구하는 경우
  - 정답을 만족하더라도 더 큰 값이 있는지 찾아야 하므로 범위를 큰 쪽으로 좁히되,
    검사한 중간 값을 포함해야함
- 만족하는 값 중 가장 작은 값을 구하는 경우
  - 정답을 만족하더라도 더 작은 값이 있는지 찾아야 하므로 범위를 작은 쫍으로 좁히되,
    검사를 중간 값을 포함해야함



**범위 표기법**

|             찾고자 하는 값              | 범위 표기법  |
| :-------------------------------------: | :----------: |
|  정답 조건을 만족하는 값 중 가장 큰 값  | [start, end) |
| 정답 조건을 만족하는 값 중 가장 작은 값 | [start, end] |

범위 안에 하나의 값만 남았다고 그 값이 무조건 정답은 아니다.
정답을 만족하는지 여부를 한번 더 검사해야 한다.



### 자바의 이진 탐색 메서드

| 자료구조 |            메서드             |
| :------: | :---------------------------: |
|   배열   |   `Arrays.binarySearch( )`    |
|  리스트  | `Collections.binarySearch( )` |



# Chapter 9. 해시

## 1. 해시란?

데이터에서 대표 값을 뽑아내는 것이다.
하나의 데이터에 해시를 적용하면 해당 데이터의 대표 값으로 변환된다.
해시로 변환된 값을 해시 값(hash value)이라고 하는데, 이는 대부분 정수로 표현하다.
값이 같고 다름을 비교하기 복잡한 데이터라면 해시를 통해 해시 값을 얻고 이를 비교하여 값의 동등 비교를 유사하게 할 수 있다.
또 해시 값을 얻을 수 있는 연산을 해시 함수(hash function)라고 한다.

하지만 해시 값은 특정 데이터를대표하는 값일 뿐 **고유한 값이 아니다.**
서로 다른 두 데이터가 같은 해시 값을 갖게 될 수 있는데 이를 해시 충돌(hash collision)이라고 한다.

해시 충돌은 해시를 사용하는 로직의 성능에 큰 영향을 미치므로,
해시 충돌을 최대한 일으키지 않는 해시 함수를 정의하는 것이 중요하다.

객체는 기본적으로 할당된 주소 값을 이용하여 해시 값을 생성하기에, 서로 다른 두 객체는 다른 해시 값을 가진다.
그래서 같은 값을 가진다고 같은 해시 값을 가지지 않을 수 있다.



### 해시 테이블

해시 테이블은 해시 값을 사용하여 이에 대응하는 원본 데이터를 찾을 수 있게 하는 자료 구조이다.
해시는 기본적으로 **단방향 변환**이다. 애초에 해시는 충돌을 허용하기 때문에 역함수는 있을 수 없다.
데이터를 저장할때 데이터를 직접적으로 갖지 않고, 여러개의 데이터를 담을 수 있는 리스트를 가지게 하여
충돌이 발생해도 모두 담을 수 있게 할 수 있다.



### 해시의 시간 복잡도

해시테이블을 이용하면 검색 등 여러 연산에 상수 시간을 기대할 수 있다.
해시 충돌이 없다면 모든 연산은 상수 시간을 갖게 된다.

해시 충돌이 발생하면, 해시 값에 데이터를 리스트 형태로 가지고 있기에
리스트의 크기가 N이라면 데이터의 크기를 찾는데 O(N)의 시간 복잡도가 소요된다.
따라서 해시 함수는 최대한 해시 충돌을 피할 수 있도록 정의해야 한다.

Java에서는 모든 클래스의 조상 클래스인 `Object` 클래스에서 해시를 위한 `hasCode( )` 메서드를 제공한다.
`hasCode( )` 메서드를 오바리이딩 해서 해시 함수를 정의할 수 있지만, 다음 규칙을 지켜야 한다.

1. 하나의 객체에서 `hasCode( )` 메서드를 여러 번 호출하더라도 항상 같은 값을 반환해야 한다.
2. 두 객체가 `equals( )` 메서드로 같다고 정의되면 `hashCode( )` 메서드도 같은 값을 반환해야 한다.
3. 두 객체가 `equals( )` 메서드로 다르다고 정의되면 `hashCode( )` 메서드는 같은 값을 반환할 수 있다.
   (해시 충돌)



위 규칙들을 지키면서 해시 충돌을 피하기 위해서는 클래스가 내포하는 데이터 특징을 파악하여
중복이 발생하지 않게끔 해시 함수를 정의하는 것이다.

코딩 테스트에서 간단하게 해시 함수를 사용하기 위해서는 문자열을 이용하면 된다.
클래스의 모든 변수를 문자열로 묶은 후 `String` 클래스의 `hashCode( )` 메서드를 호출하면
간단하지만 잘 변환된 해시 값을 얻을 수 있다.
(`String`은 Java의 기본 클래스로 `hasCode( )` 메서드가 잘 정의되어 있다)

 

`hashCode( )` 메서드를 오버라이딩 하여, 클래스가 내포하는 데이터가 같으면
같은 `hash` 값을 반환하더라도 같은 값을 가지는 객체를 `HashSet` 에서 못 찾을 수도 있다.

`HashSet`은 해시 충돌이 일어날 수 있다는 것을 알기에, 충돌인지 검사 하기 위해 `equals( )` 메서드를 호출한다.
결과가 `false` 이면 다른 데이터로 간주하여 해시 충돌이 발생했다고 인지한다.
따라서 `hashCode( )` 메서드를 오버라이딩할때는 **`equals( )` 메서드를 항상 같이 정의**해야 한다. 



# Chapter 10. 동적 프로그래밍

## 1. 동적으로 연산 줄이기

동적 프로그래밍은 완전 탐색의 일종이다. 하지만, 완전 탐색은 비효율적인 탐색 속도를 보인다.
문제가 특정 조건을 만족하면 훨씬 빠른 속도로 문제를 해결할 수 있다.



### 완전 탐색의 문제점

완전 탐색은 가능한 모든 경우의 수를 탐색하는 방법이다.
서로 다른 여러 경우의 수를 탐색 하는 데 중복된 과정이 필요할 때는 해당 과정을 여러 번 연산하게 된다.
이런 중복 과정이 많을수록 탐색 과정은 비효율적이다.



### '동적 프로그래밍'의 핵심, 메모이제이션

동적 프로그래밍은 '**메모이제이션(memoization)**' 기법을 이용한다.
한 번 풀었던 부분 문제에 대한 답을 저장해 놓았다가, 해당 부분 문제를 다시 풀 일이 생기면 재사용 하는 것이다.
메모이제이션을 적용하면 한 번 해결했던 문제를 다시 풀지 않아도 된다.



**문제에서 제시된 범위에 따라 메모지에션 배열 선언과 초기화**

재귀 구현은 부분 문제를 해결하고, 메모이제이션은 부분 문제에 대한 답을 기록한다.
메모이제이션을 하기 위해서는 답을 기록할 배열이 필요하다.
이 배열은 재귀의 점화식과 문제 조건에 따라 형태가 달라진다.

메모이제이션 배열은 상태에 포함된 변수 개수만큼 차원을 가지고, 각 변수가 각 차원의 인덱스 역할을 한다.
하나의 상태에 포함된 변수들을 사용하여 메모이제이션 배열을 참조하면 그 값이 해당 상태가 나타내는
부분 문제에 대한 답이 되는 구조다.

메모이제이션 배열을 선언한 후에는 반드시 초기화를 해야 한다.
가장 처음에는 아무런 부분 문제도 해결하지 않은 상황이기 때문에
부분 문제를 풀지 않았다는 것을 나타내야 한다.
이를 위해 정답이 될 수 없는 값으로 배열을 모두 채워 준다.



**재귀의 종료 조건에 메모이제이션 추가**

종료 조건에서 비용이 큰 연산이 있다면 메모이제이션 검사를 우선으로 하는 것이 좋다.
하지만 종료 조건이 불가능한 상태를 검사하는 것이라면 기존 종료 조건을 먼저 검사해야 한다.



**부분 문제에 대한 답을 구한 후 메모이제이션 배열에 기록**

메모이제이션되어 있지 않은 부분 문제를 풀고 난 후에는 그 답을 기록하여 이후에 같은 부분 문제를
풀 때 재사용 해야 한다. 이를 위해 답을 구한 후 메모이제이션 배열에 기록한다.



### 동적 프로그래밍의 조건

메모이제이션까지 적용햇다면 동적 프로그래밍으로 구현했다고 할 수 있다.
동적 프로그래밍 문제는 대부분 점화식을 이용한 재귀로 우선 구현하고,
메모이제이션 처리를 추가하는 방식으로 해결할 수 있다.

1. 상태 (부분 문제) 정의하기

2. 종료 조건 찾기

3. 점화식 세우기

4. 재귀로 구현하기

5. **메모이제이션 적용하기**

   

모든 문제가 동적 프로그래밍으로 변환 되는 것은 아니다. 중복이 발생하지 안하는 재귀 문제는
메모이제이션 처리를 하더라도 재사용되지 않기에 효율적이지 않다.
따라서 동적 프로그래밍을 적요하려면 반드시 중복되는 **부분 문제가 많이 발생하는지** 따져 봐야 한다.

점화식을 이용한 재귀로 구현하는 동적 프로그래밍은 직관적이고 이해하기 쉽지만
재귀 호출이 너무 깊어지만 StackOverflowError가 발생한다.

이 경우 **작은 부분 문제부터 해결**해 나갈 수 있다.



### 번외: 순차 누적으로 구현해보기

동적 프로그래밍을 반드시 재귀로 구현해야 하는 것은 아니다.
반복문을 이용한 순차 누적으로도 메모이제이션을 이용한 동적 프로그래밍을 구현할 수 있다.
큰 부분 문제를 살펴보고 이를 풀기 위해 작은 문제를 살펴보았던 재귀와는 반대로,
순차 누적은 작은 부분 문제를 먼저 해결해 나간다.



# Chapter 11. 자주 등장하는 자료 구조

## 1. 스택과 큐

스택과 큐는 원소를 특정한 순서대로 삽입하고 제거할 수 잇는 자료 구조로, 다음 연산을 제공한다.

1. 원소 삽입
2. 원소 제거
3. 자료 구조가 비어 있는지 검사



### 스택

스택은 LIFO (Last In Fisrt Out) 특징이 있는 자료 구조이다. 좁고 긴 바구니를 상상하면 된다.
원소를 집어넣으면 그대로 쌓이고, 원소를 꺼낼때는 넣은 순서의 반대로 꺼낸다.

원소 추가는 `add( )` 메서드, 삭제는 `pop( )` 메서드로 할 수 있는데, `pop( )` 메서드를 호출하면 제거된 원소가 반환된다.
스택이 비어있는 경우 `pop( )` 호출시 `EmptyStackException`이 발생하기에, `isEmpty( )` 메서드로 스택이 비어있는지 확인하고
`pop( )`을 호출하는 것이 중요하다.
`peek( )` 메서드는 스택에서 값을 제거하지 않고도 스택의 가장 위에 있는 값을 얻을 수 있다.
`peek( )` 메서드 또한 스택이 비어있으면 `EmptyStackExcetpion`이 발생하기에 주의해야 한다.

스택은 주로 짝을 찾는 문제에서 자주 활용된다.



### 큐

큐는 FIFO (First In First Out) 특징이 있는 자료 구조이다. 긴 빨때를 생각하면 된다.
원소를 집어넣은 순서대로 원소가 제거된다.

Java에서는 큐가 인터페이스로 작성되어 있기에, 큐를 이용 하려면 인터페이스 `Queue`를 구현하는 클래스를 사용해야 한다.
이를 위해 가장 많이 활됴되는 클래스는 `LinkedList` 이다.

`Queue` 인터페이스가 제공하는 `add( )`와 `poll( )` 메서드를 사용하면 다음과 같이 원소를 삽입하고 제거할 수 있다.
`Stack`과 마찬가지로 `isEmpty( )` 메서드를 사용해서 자료구조가 비었는지 확인할 수 있다.
