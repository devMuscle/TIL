# 프로그래머스 코딩 테스트 문제 풀이 전략: 자바편

[링크](https://product.kyobobook.co.kr/detail/S000200928002)

# Chapter1. 코딩 테스트

## 1. 전화번호 나타내기

String의 replaceAll 메서드와 정규식을 사용하여 문자열 형태 통일하기



## 2. 전화번호부의 사람 나타내기

전화번호를 다량 보유한 사람을 List 자료구조로 관리하기



## 3. 사람과 전화번호 비교하기

전화번호 기반으로 사람을 비교하기 위해 List의 contains 메서드를 활용
이때 contains는 equals 메서드를 기반으로 동작하기에 객체가 아닌 전화번호를 기반으로 비교하기 위해 equals 메서드 오버라이딩



## 4. 전화번호부 나타내기

동일한 객체의 중복을 방지하기 위해 List가 아닌 Set 자료구조 채택

전화번호부에서 해당 전화번호를 가지고있는 사람을 찾기위해 stream().filter() 사용 



# Chapter 4. 문자열

## 1. 문자열이란

### 문자의 배열

문자열 String은 내부적으로 문자의 배열을 이용해서 표현
다음과 같은 방법으로 문자에 접근 가능

- ```String.charAt(int index)```
- ```String.toCharArray()```



### 아스키코드

문자는 내부적으로 정수로 취급되고 연산된다.
정수와 문자를 바꾸는 규칙으로 아스키 코드를 사용한다.



### StringBuilder

```String```은 문자열을 수정할때 마다 새로운 문자열을 만들기 때문에 시간, 공간적으로 효율적이지 못하다.
```StringBuilder```는 수정할때마다 내부 배열에서 직접 수정한다.



# Chapter 5. 재귀

## 1. 재귀란?

재귀는 메서드 호출을 이요한 방법으로, 하나의 메서드 내에서 자기 자신을 호출하도록 하여 반복적인 개념을 구현하는 것이다.
하나의 재귀 호출은 하나의 부분 문제를 해결한다.



### for문에서 벗어나기

같은 로직을 이용한 반복작업은 반복문을 이용해서 해결할 수 있다.
하지만 배열에서 n개의 원소를 합치는 작업을 반복문으로 해결할려고 하면 n중 반복문을 만들게 될 수도 있는 것이다.



### 재귀의 최대 범위와 한계점 기억하기

재귀 호출은 반복 작업을 구현하는 것이기에 재귀의 호출 횟수가 시간 복잡도에 직접적으로 영향을 끼친다.
그래서 재귀 호출이 얼마나 수행되는지와 한 번 호출했을 때 어떤 작업을 하는지 잘 따져야 한다.

재귀 호출의 깊이도 주의 깊게 살펴 보아야 한다.
재귀 호출된 메서드에서 사용하는 변수들은 메모리에 추가 할당된다.
이 변수들은 재구 호출이 종료되어야 메모리에서 할당이 해제된다.

재귀 호출이 너무 깊게 들어가버리면 변수들이 메모리를 모두 할당해서 **StackOverFlow** 예외가 발생한다.
이것을 방지하기 위해서는 재귀 호출의 깊이를 **10,000 이하** 아무리 많아도 20,000 이하로 유지해야 한다.



## 2. 재귀 정의하기

### 상태 정의하기

재귀는 **부분 문제**를 해결해 나가는 풀이 방법이다.
부분 문제는 각각 하나의 명확한 문제를 나타내어 하나의 답을 낼 수 있어야 한다.
답을 내는 데 입력되는 변수들이 필요하고, 이렇게 답을 결정하는 변수들을 **상태**라고 한다.
그리고 부분 문제는 하나의 상태에 대한 답을 찾는 문제가 된다.



### 종료 조건

부분 문제는 상태에 대한 답을 찾는 것이므로 부분 문제가 나타내는 상태가 재귀가 진행될수록 점점 작아져,
결국 이어지는 부분 문제 없이 즉시 답이 나와야 한다.
이렇게 즉시 답이 나오는 상태를 검사하여 답을 반환할 수 있도록 하는 것을 **종료 조건**이라고 하고,
종료 조건에 도달할 수 있도록 부분 문제로 상태가 변해 가는 것을 **상태가 작아진다**고 한다.



### 점화식

부분 문제는 같은 규칙으로 더 작은 부분 문제로 진행되어야 한다.
따라서 상태 또한 하나의 규칙으로 더작은 상태로 전이되어야 한다.
이렇게 **상태를 전이시키는 규칙을 점화식**이라고 한다.



# Chapter 6. 완전 탐색

## 1. 완전 탐색이란?

완전 탐색은 문제에서 제시하는 조건을 만족하는 모든 경우를 확인하면서 정답을 찾는 탐색이다.
이 방식은 구현만 제대로 한다면 가능한 모든 경우를 빠짐없이 확인하기 때문에 무조건 정답을 찾을 수 있는 정확성이 높은 탐색이다.
완전 탐색을 이용해서 문제를 해결할때 필수적으로 시간 복잡도를 확인해야 하는데,
시간 복잡도가 충분히 작다면 완전 탐색을 적용하는 것이 가장 나을 수 있다.



### 상태와 상태 전이 진행

완전 탐색에서는 탐색을 진행하면서 상태를 전이시켜 나간다.
완전 탐색의 상태에는 탐색의 진행 상태를 표현할 수 있는 변수들이 포함되고,
하나의 상태를 이용해서 다음 상태를 만들어 나가는상태 전이를 통해 탐색을 진행한다.



### 완전 탐색의 종류

완전 탐색은 가능한 모든 경우를 검사하는 탐색으로 문제 조건에 따라 구현하는 방법이 달라진다.



**간단히 구현되는 완전 탐색**

난이도가 낮은 문제는 간단한 완전 탐색으로 해결될 때가 있다.
이 경우 특별한 구현 없이 중첩 for 문 정도로 완전 탐색을 구현할 수 있다.



**깊이 우선 탐색**

깊이 우선 탐색(Depth First Search, DFS) 는 재귀로 쉽게 구현할 수 있는 완전 탐색 방법이다.
재귀로 구현되기 때문에 상태 전이를 여러 방법으로 할 수 있다면
하나의 전이 방법을 더 이상 불가능할 때까지 연속적으로 적용한다는 특징이 있다.



**너비 우선 탐색**

너비 우선 탐색(Breadth First Search, BFS)은  자료 구조인 큐를 이용하여 구현되는 완전 탐색 방법이다.
너비 우선 탐색은 깊이 우선 탐색과는 다르게 하나의 상태에서 전이되는 다음 단계의 상태들을 방문한 후 그 다음 상태들을 방문한다.



### 방문 처리

완전 탐색의 시간 복잡도는 탐색해야 할 상태 개수, 즉 탐색 공간의 크기에 비례한다.
이렇게 탐색 공간의 크기를 이용하여 완전 탐색의 시간 복잡도를 계산할 때는 한 번 방문한 상태를  재방문해서는 안 된다.
중복으로 탐색하는 공간이 클 수록 더 큰 시간 복잡도를 낳게 되기에 방지를 위해 방문 처리를 해야한다.



# Chapter 7. 정렬

## 1. 정렬이란?

### 정렬 기준 잡기

하나의 데이터라도 포함된 데이터 종류에 따라 다양한 기준으로 정렬할 수 있다.
따라서 문제를 잘 파악하고 문제의 요구 사항에 맞게 정렬 기준을 잘 선택해야 한다.



### 정렬 효율 높이기

리스트를 순회하는데는 O(N) 의 시간복잡도가 소요되는데, 정렬은 O(N * logN) 이 소요된다.
데이터 구조와 문제 조건에 따라 데이터를 비교하는 방법과 시간 복잡도가 달라지므로
불필요한 비교와 정렬은 최소화하고 문제 조건을 맞출 수 있는 최소한의 정렬을 진행해야 한다.



## 2. 정렬하기

### 직접 기준 정하기

모든 문제를 기본 정렬 기준을 사용해서 해결할 수 있는 것은 아니다.
아름차순이 아닌 내림차순으로 정렬하거나, 클래스를 정렬해야 할 수도 있다.



**Comparator<T>** 사용하기

정렬 메서드들은 Comparator<T>를 매개변수로 받을 수 있다.
Comparator<T>는 compare 메서드를 가지는 자바의 제네릭 인터페이스다.



**Comparator<T>의 반환 값**

compare 메서드는 제네릭 타입 T의 객체를 받아 비교한다.

| 부호 |       비교 결과       |
| :--: | :-------------------: |
|  0   |    두 객체가 같다     |
| 양수 |  왼쪽 객체가 더 크다  |
| 음수 | 오른쪽 객체가 더 크다 |

v1 - v2 의 결과라고 생각하면 된다.



# Chapter 8. 이진 탐색

## 1. 이진 탐색이란?

이진 탐색은 업다운 게임과 같다.
찾고자 하는 정답이 포함된 범위 중 가운데를 검사하고, 정답과 비교하여 절반의 범위를 제외한다.



### 이진 탐색이 갖는 이점

선형 탐색은 O(N)의 시간 복잡도를 가진다. 이는 업다운 게임에서 1부터 N까지 차례대로 부르는 것과 같다.
이진 탐색은 O(logN)의 시간 복잡도를 가진다. 이는 선형 탐색보다 N이 크면 클수록 성능이 강력하다.



### 이진 탐색을 사용할 수 있는 조건

이진 탐색을 적용하려면 배열이나 리스트가 **정렬되어 있어야** 한다.
정렬된 상태이어야 대소 비교를 하여 정답이 없는 구간을 확실히 제외할 수 있다.



## 2. 탐색 효율 높이기

### 분할 정복

이진 탐색은 남은 밤위를 계속해서 반으로 나눈다.
이렇게 탐색 공간을 특정 기준에 따라 나누고, 나눈 각 탐색 공간에서 탐색을 이어 나가는 것을 분할 정복이라고 한다.



### 정렬 기준 정하기

이진 탐색을 진행하려면 배열이 정렬되어 있어야 하기에, 정렬 규칙을 찾아내어 이진 탐색을 적용해야 한다.



### 정렬 방식 선택하기

이진 탐색을 적용하려면 문제에서 요구하는 조건을 정확히 파악하고,
이에 따른 대소 비교를 구현하여 데이터를 정렬한 후 진행해야 한다.



### 정렬 규칙 찾기

이진 탐색은 정답 조건을 만족하는 값 중 **가장 큰 값** 혹은 **가장 작은 값**을 찾는데도 많이 사용된다.
이런 유형의 탐색을 파라메트릭 서치라고도 한다.

이런 값을 찾으려면 다음 고민을 해야 한다.

1. 범위 좁히기
2. 범위 표기법



**범위 좁히기**

정확한 값을 찾는 이진 탐색과 다르게 가장 큰 값이나 가장 작은 값을 찾는 이진 탐색에서는
검사한 값이 정답 조건을 만족한다고 하더라도 범위에 포함될 수 있다. 따라서 범위를 좁힐 때 이를 반영해야 한다.

- 만족하는 값 중 가장 큰 값을 구하는 경우
  - 정답을 만족하더라도 더 큰 값이 있는지 찾아야 하므로 범위를 큰 쪽으로 좁히되,
    검사한 중간 값을 포함해야함
- 만족하는 값 중 가장 작은 값을 구하는 경우
  - 정답을 만족하더라도 더 작은 값이 있는지 찾아야 하므로 범위를 작은 쫍으로 좁히되,
    검사를 중간 값을 포함해야함



**범위 표기법**

|             찾고자 하는 값              | 범위 표기법  |
| :-------------------------------------: | :----------: |
|  정답 조건을 만족하는 값 중 가장 큰 값  | [start, end) |
| 정답 조건을 만족하는 값 중 가장 작은 값 | [start, end] |

범위 안에 하나의 값만 남았다고 그 값이 무조건 정답은 아니다.
정답을 만족하는지 여부를 한번 더 검사해야 한다.



### 자바의 이진 탐색 메서드

| 자료구조 |            메서드             |
| :------: | :---------------------------: |
|   배열   |   `Arrays.binarySearch( )`    |
|  리스트  | `Collections.binarySearch( )` |



# Chapter 9. 해시

## 1. 해시란?

데이터에서 대표 값을 뽑아내는 것이다.
하나의 데이터에 해시를 적용하면 해당 데이터의 대표 값으로 변환된다.
해시로 변환된 값을 해시 값(hash value)이라고 하는데, 이는 대부분 정수로 표현하다.
값이 같고 다름을 비교하기 복잡한 데이터라면 해시를 통해 해시 값을 얻고 이를 비교하여 값의 동등 비교를 유사하게 할 수 있다.
또 해시 값을 얻을 수 있는 연산을 해시 함수(hash function)라고 한다.

하지만 해시 값은 특정 데이터를대표하는 값일 뿐 **고유한 값이 아니다.**
서로 다른 두 데이터가 같은 해시 값을 갖게 될 수 있는데 이를 해시 충돌(hash collision)이라고 한다.

해시 충돌은 해시를 사용하는 로직의 성능에 큰 영향을 미치므로,
해시 충돌을 최대한 일으키지 않는 해시 함수를 정의하는 것이 중요하다.

객체는 기본적으로 할당된 주소 값을 이용하여 해시 값을 생성하기에, 서로 다른 두 객체는 다른 해시 값을 가진다.
그래서 같은 값을 가진다고 같은 해시 값을 가지지 않을 수 있다.



### 해시 테이블

해시 테이블은 해시 값을 사용하여 이에 대응하는 원본 데이터를 찾을 수 있게 하는 자료 구조이다.
해시는 기본적으로 **단방향 변환**이다. 애초에 해시는 충돌을 허용하기 때문에 역함수는 있을 수 없다.
데이터를 저장할때 데이터를 직접적으로 갖지 않고, 여러개의 데이터를 담을 수 있는 리스트를 가지게 하여
충돌이 발생해도 모두 담을 수 있게 할 수 있다.



### 해시의 시간 복잡도

해시테이블을 이용하면 검색 등 여러 연산에 상수 시간을 기대할 수 있다.
해시 충돌이 없다면 모든 연산은 상수 시간을 갖게 된다.

해시 충돌이 발생하면, 해시 값에 데이터를 리스트 형태로 가지고 있기에
리스트의 크기가 N이라면 데이터의 크기를 찾는데 O(N)의 시간 복잡도가 소요된다.
따라서 해시 함수는 최대한 해시 충돌을 피할 수 있도록 정의해야 한다.

Java에서는 모든 클래스의 조상 클래스인 `Object` 클래스에서 해시를 위한 `hasCode( )` 메서드를 제공한다.
`hasCode( )` 메서드를 오바리이딩 해서 해시 함수를 정의할 수 있지만, 다음 규칙을 지켜야 한다.

1. 하나의 객체에서 `hasCode( )` 메서드를 여러 번 호출하더라도 항상 같은 값을 반환해야 한다.
2. 두 객체가 `equals( )` 메서드로 같다고 정의되면 `hashCode( )` 메서드도 같은 값을 반환해야 한다.
3. 두 객체가 `equals( )` 메서드로 다르다고 정의되면 `hashCode( )` 메서드는 같은 값을 반환할 수 있다.
   (해시 충돌)



위 규칙들을 지키면서 해시 충돌을 피하기 위해서는 클래스가 내포하는 데이터 특징을 파악하여
중복이 발생하지 않게끔 해시 함수를 정의하는 것이다.

코딩 테스트에서 간단하게 해시 함수를 사용하기 위해서는 문자열을 이용하면 된다.
클래스의 모든 변수를 문자열로 묶은 후 `String` 클래스의 `hashCode( )` 메서드를 호출하면
간단하지만 잘 변환된 해시 값을 얻을 수 있다.
(`String`은 Java의 기본 클래스로 `hasCode( )` 메서드가 잘 정의되어 있다)

 

`hashCode( )` 메서드를 오버라이딩 하여, 클래스가 내포하는 데이터가 같으면
같은 `hash` 값을 반환하더라도 같은 값을 가지는 객체를 `HashSet` 에서 못 찾을 수도 있다.

`HashSet`은 해시 충돌이 일어날 수 있다는 것을 알기에, 충돌인지 검사 하기 위해 `equals( )` 메서드를 호출한다.
결과가 `false` 이면 다른 데이터로 간주하여 해시 충돌이 발생했다고 인지한다.
따라서 `hashCode( )` 메서드를 오버라이딩할때는 **`equals( )` 메서드를 항상 같이 정의**해야 한다. 



# Chapter 10. 동적 프로그래밍

## 1. 동적으로 연산 줄이기

동적 프로그래밍은 완전 탐색의 일종이다. 하지만, 완전 탐색은 비효율적인 탐색 속도를 보인다.
문제가 특정 조건을 만족하면 훨씬 빠른 속도로 문제를 해결할 수 있다.



### 완전 탐색의 문제점

완전 탐색은 가능한 모든 경우의 수를 탐색하는 방법이다.
서로 다른 여러 경우의 수를 탐색 하는 데 중복된 과정이 필요할 때는 해당 과정을 여러 번 연산하게 된다.
이런 중복 과정이 많을수록 탐색 과정은 비효율적이다.



### '동적 프로그래밍'의 핵심, 메모이제이션

동적 프로그래밍은 '**메모이제이션(memoization)**' 기법을 이용한다.
한 번 풀었던 부분 문제에 대한 답을 저장해 놓았다가, 해당 부분 문제를 다시 풀 일이 생기면 재사용 하는 것이다.
메모이제이션을 적용하면 한 번 해결했던 문제를 다시 풀지 않아도 된다.



**문제에서 제시된 범위에 따라 메모지에션 배열 선언과 초기화**

재귀 구현은 부분 문제를 해결하고, 메모이제이션은 부분 문제에 대한 답을 기록한다.
메모이제이션을 하기 위해서는 답을 기록할 배열이 필요하다.
이 배열은 재귀의 점화식과 문제 조건에 따라 형태가 달라진다.

메모이제이션 배열은 상태에 포함된 변수 개수만큼 차원을 가지고, 각 변수가 각 차원의 인덱스 역할을 한다.
하나의 상태에 포함된 변수들을 사용하여 메모이제이션 배열을 참조하면 그 값이 해당 상태가 나타내는
부분 문제에 대한 답이 되는 구조다.

메모이제이션 배열을 선언한 후에는 반드시 초기화를 해야 한다.
가장 처음에는 아무런 부분 문제도 해결하지 않은 상황이기 때문에
부분 문제를 풀지 않았다는 것을 나타내야 한다.
이를 위해 정답이 될 수 없는 값으로 배열을 모두 채워 준다.



**재귀의 종료 조건에 메모이제이션 추가**

종료 조건에서 비용이 큰 연산이 있다면 메모이제이션 검사를 우선으로 하는 것이 좋다.
하지만 종료 조건이 불가능한 상태를 검사하는 것이라면 기존 종료 조건을 먼저 검사해야 한다.



**부분 문제에 대한 답을 구한 후 메모이제이션 배열에 기록**

메모이제이션되어 있지 않은 부분 문제를 풀고 난 후에는 그 답을 기록하여 이후에 같은 부분 문제를
풀 때 재사용 해야 한다. 이를 위해 답을 구한 후 메모이제이션 배열에 기록한다.



### 동적 프로그래밍의 조건

메모이제이션까지 적용햇다면 동적 프로그래밍으로 구현했다고 할 수 있다.
동적 프로그래밍 문제는 대부분 점화식을 이용한 재귀로 우선 구현하고,
메모이제이션 처리를 추가하는 방식으로 해결할 수 있다.

1. 상태 (부분 문제) 정의하기

2. 종료 조건 찾기

3. 점화식 세우기

4. 재귀로 구현하기

5. **메모이제이션 적용하기**

   

모든 문제가 동적 프로그래밍으로 변환 되는 것은 아니다. 중복이 발생하지 안하는 재귀 문제는
메모이제이션 처리를 하더라도 재사용되지 않기에 효율적이지 않다.
따라서 동적 프로그래밍을 적요하려면 반드시 중복되는 **부분 문제가 많이 발생하는지** 따져 봐야 한다.

점화식을 이용한 재귀로 구현하는 동적 프로그래밍은 직관적이고 이해하기 쉽지만
재귀 호출이 너무 깊어지만 StackOverflowError가 발생한다.

이 경우 **작은 부분 문제부터 해결**해 나갈 수 있다.



### 번외: 순차 누적으로 구현해보기

동적 프로그래밍을 반드시 재귀로 구현해야 하는 것은 아니다.
반복문을 이용한 순차 누적으로도 메모이제이션을 이용한 동적 프로그래밍을 구현할 수 있다.
큰 부분 문제를 살펴보고 이를 풀기 위해 작은 문제를 살펴보았던 재귀와는 반대로,
순차 누적은 작은 부분 문제를 먼저 해결해 나간다.



# Chapter 11. 자주 등장하는 자료 구조

## 1. 스택과 큐

스택과 큐는 원소를 특정한 순서대로 삽입하고 제거할 수 잇는 자료 구조로, 다음 연산을 제공한다.

1. 원소 삽입
2. 원소 제거
3. 자료 구조가 비어 있는지 검사



### 스택

스택은 LIFO (Last In Fisrt Out) 특징이 있는 자료 구조이다. 좁고 긴 바구니를 상상하면 된다.
원소를 집어넣으면 그대로 쌓이고, 원소를 꺼낼때는 넣은 순서의 반대로 꺼낸다.

원소 추가는 `add( )` 메서드, 삭제는 `pop( )` 메서드로 할 수 있는데, `pop( )` 메서드를 호출하면 제거된 원소가 반환된다.
스택이 비어있는 경우 `pop( )` 호출시 `EmptyStackException`이 발생하기에, `isEmpty( )` 메서드로 스택이 비어있는지 확인하고
`pop( )`을 호출하는 것이 중요하다.
`peek( )` 메서드는 스택에서 값을 제거하지 않고도 스택의 가장 위에 있는 값을 얻을 수 있다.
`peek( )` 메서드 또한 스택이 비어있으면 `EmptyStackExcetpion`이 발생하기에 주의해야 한다.

스택은 주로 짝을 찾는 문제에서 자주 활용된다.



### 큐

큐는 FIFO (First In First Out) 특징이 있는 자료 구조이다. 긴 빨때를 생각하면 된다.
원소를 집어넣은 순서대로 원소가 제거된다.

Java에서는 큐가 인터페이스로 작성되어 있기에, 큐를 이용 하려면 인터페이스 `Queue`를 구현하는 클래스를 사용해야 한다.
이를 위해 가장 많이 활됴되는 클래스는 `LinkedList` 이다.

`Queue` 인터페이스가 제공하는 `add( )`와 `poll( )` 메서드를 사용하면 다음과 같이 원소를 삽입하고 제거할 수 있다.
`Stack`과 마찬가지로 `isEmpty( )` 메서드를 사용해서 자료구조가 비었는지 확인할 수 있다.



## 2. 그래프와 트리

### 그래프

그래프는 정점(vertex) 혹은 노드(node)와 간선(edge)으로 구성된 자료 구조입니다.
간선이 정점을 잇는 형태로 구성됩니다.

**그래프의 종류**

- **무향 그래프**

  간선에 방향이 없는 그래프이다.
  하나의 정점이 다른 정점과 방향이 없는 그래프로 이어져 있으면 두 정점이 서로 연결되어 있는 것이다.
  간선을 따라 다른 정점에 도달할 수 있으면, 그 간선을 **경로** 라고 한다.

- **방향 그래프**

  간선에 방향이 있는 그래프이다.
  간선은 해당 방향으로만 이동할 수 있다.



**그래프 나타내기**

그래프를 나타내려면 정점과 정점들이 어떻게 연결되어 있는지 나타내는 간선 정보를 표현할 수 있어야 한다.

- **인접 행렬**

  인접 행렬(adjency matrix)은 그래프를 가장 쉽게 표현하는 방식이다.
  그래프를 정사각형 모양의 2차원 배열로 나타낸다.
  배열의 각 인덱스는 정점을 의미하고, 원소는 각 차원의 인덱스에 해당하는 정점 사이에
  간선이 있는지 나타낸다.

  구현하기 매우 쉬우며, 두 정점 사이에 간선이 존재하는지 알려면 원소를 참조하면 되므로
  상수 시간이 소요된다.
  하지만 2차원 배열로 선언해야 한다는 점에서 정점 개수가 너무 많으면 배열을 할당하지 못할 수도 있고
  정점을 찾으려면 2차원 배열에서 하나의 열을 모두 순회해야 한다는 단점이 있다.

- **인접 리스트**

  인접 리스트(adjency list)는 정점이 연결된 정점들을 리스트로 표현하는 방식이다.
  원소가 리스트인 1차원 배열로 표현할 수 있다.
  간선 정보만 담기 때문에 인접 행렬 방식에 비해서 필요한 메모리가 훨씬 적다.
  따라서 정점 개수가 많은 문제에도 적용할 수 있고, 특정 정점과 간선으로 연결된 정점들만
  쉽게 순회할 수도 있다.

  반면 임의의 두 정점 사이에 간선이 있는지 알려면
  한 정점과 연결된 모든 정점을 순회하며 찾아봐야 한다.



**그래프 탐색하기**

대부분 그래프의 정점이 문제에서 요구하는 데이터를 나타낸다.
따라서 그래프 문제는 간선을 따라 정점을 순회하며 문제 조건에 맞는 정답을 찾게 된다.
대표적인 방법이 깊이 우선 탐색(Depth First Search) 와 너비 우선 탐색(Breadth First Search)이다.



### 트리와 이진 트리

트리는 그래프의 일종인 자료 구조이다.
트리에서는 정점 대신 노드(node)라는 용어를 많이 사용한다.
노드는 계층 구조를 갖는데, 한 노드의 상위 노드를 부모 노드, 하위 노드를 자식 노드라고 한다.
하나의 노드는 최대 1개의 부모 노드와 여러개의 자식 노드를 가질 수 있다.



**트리의 구조**

트리는 최상층에 단 하나의 노드가 있어야 한다. 이 노드를 **루트 노드(root node)**라고 한다.
트리를 구성하는 모든 노드는 이 루트 노드에서 파생된 자손 노드이다.
루트 노드는 유일하게 부모 노드가 없는 노드이다.

자식 노드가 없는 노드들을 **리프 노드(leaf node)**라고 한다.
리프 노드는 트리에서 여러개 일 수 있다.

하나의 노드에서 자식 노드로 내려갈수록 트리에서 깊이는 점점 깊어지며,
트리에서 가장 깊은 노드 깊이를 트리 **깊이(depth)** 또는 트리 **높이(height)**라고 한다.



**트리의 구현**

트리는 재귀적 특성을 갖는다. 트리를 구성하는 임의의 노드를 선택했을 때
해당 노드를 루트노드로 하는 트리를 원본 트리의 **서브 트리(subtree)** 라고 한다.
재귀적 특성이란 이 서브 트리 또한 트리 성질을 모두 지닌다는 것이다.



**이진 트리**

트리를 구성하는 모든 노드가 최대 2개의 자식 노드를 가질때 이 트리를 **이진 트리(binary tree)**라고 한다.
이진 트리는 최대 2개의 자식 노드를 가지기 때문에, 각 자식을 왼쪽 자식과 오른쪽 자식 이라고 한다.



**이진 트리의 순회**

트리는 여러 개의 자식을 가질 수 있으므로 재귀를 이용해서 쉽게 순회할 수 있다.
이진 트리도 트리이므로 같은 방식으로 순회할 수 있다.
이진 트리 순회는 노드를 방문하는 순서에 따라 세 가지로 구분할 수 있다.

- **전위 순회**

  노드를 서브 트리 순회 전에 방문하는 순회 방식
  '노드 => 왼쪽 서브 트리 => 오른쪽 서브 트리' 순서로 순회

- **중위 순회**

  왼쪽 서브 트리 방문 이후 노드를 방문하고, 오른쪽 서브 트리를 방문하는 순회 방식
  '왼쪽 서브 트리 => 노드 => 오른쪽 서브 트리' 순서로 순회

- **후위 순회**

  양쪽 서브 트리를 모두 방문한 후 노드를 방문하는 순회 방식
  '왼쪽 서브 트리 => 오른쪽 서브 트리 => 노드' 순서로 순회



### 3. 잊을 만하면 나오는 자료 구조

### 우선순위 큐

우선순위 큐(priority queue)는 힙(heap)이라고도 하며, 특정 원소 중에서 최대 우선순위를 가지는 값을
효율적으로 구하려고 고안된 자료구조 이다.
우선순위 큐는 원소의 삽입, 최대 우선 순위 값 뽑기 2가지 연산을 지원한다.

내부적으로 이진 트리를 사용하여 원소 개수를 N이라고 했을 때, 삽입과 값 뽑기 두 연산 모두 O(logN)의 시간복잡도로 제공한다.

무작위로 섞여 있는 원소들을 모두 우선순위 큐에 넣은 후 최대 우선순위 값을 계속해서 뽑아 내면 원소들이 정렬되고,
시간 복잡도는 O(N logN)이 된다. 이러한 정렬 방법을 힙 정렬(heap sort)라고 한다.

Java에서는 우선 순위 큐를 `java.util` 패키지의 `PriorityQueue<E>` 제네릭 클래스로 지원한다.
`Queue` 인터페이스와 같이 값을 추가하는 `add( )` 메서드와 최대 우선순위 값을 뽑는 `poll( )` 메서드를 지원한다.

정수의 경우 작은 값일수록 높은 우선순위를 가진다.
이 기준은 `Comparator`를 생성자에 넘겨서 직접 설정할 수도 있다.



### 투 포인터

투 포인터(two pointer)는 특정 조건을 만족하는 연속적 구간을 찾을 때 유용하다.
투포인터에서는 구간의 시작과 끝을 가리키는 두 포인터를 하나씩 이동시켜 가며 구간을 찾는다.



# Chapter 12. 구현

코딩 테스트에서 문제를 구현하기 위한 로직을 얼마나 탄탄하게 구성하고, 이를 코드로 잘 옮길 수 있는지
확인하는 문제가 종종 출제된다. 이를 위해서는 여러 가지 경우의 수를 따져 보고, 자신의 생각을 코드로 작성할 수 있어야 한다.



## 1. 주의해야 할 점

구현 문제를 해결하다 보면 생각나는 대로 코드를 작성하다 실수하는 경우가 많다.
이러한 실수를 줄이려면 어떤 점에 주의해야 하는지 살펴보자.



### 구현이 어려운 문제인 이유

구현 문제는 이미 알고 있는 알고리즘이나 자료 구조를 응용하는 것 뿐만 아니라
직접 문제를 해결할 수 있는 규칙을 세우고, 이를 코드로 옮겨야 한다.
규칙을 복잡하게 설정해야 할수록, 그리고 작성해야 하는 코드가 복잡할수록 구현 문제를 풀 때 실수를 많이 한다.



### 문제 나누어서 생각하기: 모듈화

실수를 줄이는 가장 쉬운 방법은 모듈화 하는 것이다.
코드를 한 번에 작성하지 않고, 역할별로 나누어 부분적으로 작성해 나가면 한 번에 한 가지만 집중할 수 있습니다.
모듈화의 핵심은 코드를 역할별로 나누는 것이다. 코드 역할을 고려하지 않고 단순히 코드를 짧게 분리시키기만 한다면
오히려 로직을 따라가고자 이곳저곳을 옮겨 다니며 코드를 읽어야 하므로 코드가 번잡해진다.

모듈화에서 가장 작은 단위는 메서드다.
따라서 처음에는 역할별로 메서드를 분리하여 작성하여, 하나의 작업만 처리할 수 있도록 한다면
메서드를 작성할 떄 오로지 하나의 부분 로직에만 집중할 수 있다.

메서드를 작성할 때는 최소한의 매개변수만 받도록 한다.
최소한의 매개변수를 정의할 수 있다는 것은 메서드 역할을 확실히 정의했다는 의미다.
따라서 메서드가 담당하는 역할에 따라 최소한의 매개변수를 찾고, 실제 구현에서도 해당 매개 변수들만 사용하자.

클래스로 분리하는 것도 아주 좋은 방법이다.
데이터를 담는 클래스를 작성하고, 클래스의 메서드로 해당 클래스의 객체를 다루는 방법을 작성한다면
마찬가지로 하나의 부분로직에만 집중할 수 있다.
클래스 또한 역할을 고려하여 최소한의 데이터와 메서드를 포함하도록 작성한다.
하나의 클래스가 너무 많은 데이터와 메서드를 가진다면 여러 개의 클래스로 분리하는 것도 좋은 방법이다.

메서드나 클래스를 역할별로 분리하면 해당 메서드나 클래스를 작성할 때만 부분 로직을 신경쓰면 된다.
한 번 작성 완료하면 해당 부분의 로직은 더 이상 신경 안써도 되며, 그 역할만 기억하고 이용하면 된다.

처음에는 역할별로 나누는게 어려울 수 있으나, 문제의 구성을 확인하고, 문제 자체를 나누어서 생각해 보자.
청므부터 끝까지 하나의 로직으로만 구성되는 문제는 없다. 대부분 단계별로 넘어가는 구조일 것이다.
이 단계별 구조를 파악하면 코드를 역할별로 분리할 수 있는 첫번째 힌트가 될 것이다.



### 디버깅 빨리하기

모듈화가 잘 된 코드는 디버깅도 쉽게 할 수 있다.
코드가 단계별, 역할별로 분리되어 있기 때문에 중간중간 로그를 찍어 보는 것만으로도
어떤 단계에서 어떤 역할이 제대로 동작하고 있는지 파악할 수 있다.

하나의 단계 혹은 역할을 하는 메서드나 클래스를 작성할 때마다 임의의 입력을 넣고 코드를 실행해보자.
결과가 부합한다면 정상적으로 동작한다고 믿고 다음 단계로 진행할 수 있다.

모든 경우의 수를 판단할 수는 없지만, 간단한 실수나 로직상 문제는 초기에 잡아낼 수 있으므로
전체 코드를 작성하고 디버깅 하는 것보다 훨씬 빠르게 코드를 작성할 수 있을 것이다.

## 2. 문제에서 이야기하는 대로 만들기

구현 문제는 규칙을 찾고 생각을 코드로 옮기는 문제이다.
최적화나 기법을 활용하기 전에 문제의 요구 조건을 그대로 옮기는 것이 문제를 더욱 효율적으로 풀 수 있다.
처음부터 효율성을 고려하여 최적화를 시도하다 보면 문제 조건과 맞지 않은 최적화를 적용하거나 시간이 부족할 수 있다.



### 규칙 찾아보기

구현 문제는 규칙을 꼼꼼히 명시해 놓는다.
로직을 생각할 때 메인 규칙과 예외 상황에 적용되는 규칙을 찾고, 이를 문제의 요구 조건에서 확인하여 처리한다.
문제에서 제공하는 대부분의 규칙은 시간 복잡도와 관련된 입력 크기 제한이나 예외 경우를 제외하는 규칙들이다.
규칙을 잘 살펴보지 않으면 실제로 입력에서 주어지지 않는 예외 경우들을 처리하느라 시간을 낭비할 수 있다.



## 3. 완전 탐색 기반으로 풀기

### 깊이 우선 탐색 (DFS)

깊이 우선 탐색은 가장 기본적인 완전 탐색 알고리즘으로, 재귀를 이용하면 쉽게 구현할 수 있다.
DFS는 **탐색 공간이 제한**되어 있고, **탐색 공간 내 탐색 목표가 있는지 검사**할 때 유용하게 사용된다.



**DFS의 탐색 순서**

DFS는 재귀로 구현되므로 재귀 특성을 갖습니다. 따라서 현재 검사하는 상태에서 **전이할 수 있는 상태가 있으면**
**해당 상태로 우선 전이**한다.

1. **탐색 공간의 깊이 제한**

   DFS는 이런 재귀 특성 때문에 탐색 공간의 깊이가 제한되어 있지 않은 문제에서는 적용하기 힘들다.
   원하는 값에 도달하지 못하고 잘못된 방향으로만 전이할 수도 있다.
   따라서 DFS는 탐색 공간 깊이가 제한되어 있어 모든 탐색 공간을 탐색할 수 있을때만 적용해야 한다.

2. **최단 경로를 찾지 못함**

   DFS는 목표 상태까지 최단 경로를 찾지 못한다.
   DFS는 전이 가능한 상태로 우선 전이하기 때문에 다른 경로를 탐색하게 된다.
   탐색 공간 내 목표 상태가 있음은 확인할 수 있지만, 최단 경로는 찾지 못한다.

3. **작은 공간 복잡도**

   DFS는 전이할 수 있으면 바로 전이하는 특성 덕분에 작은 공간 복잡도를 가진다.
   탐색 공간의 최대 깊이가 H일때, DFS는 O(H)의 공간 복잡도를 소요한다.



**DFS: 스택**

DFS는 재귀로 구현된다. 재귀는 콜 스택이 쌓이는 형식이기 때문에 직접 스택으로 구현할수도 있다.

```java
//(1) 방문 검사 배열
boolean[] isVisited = new boolean[N];

Stack<Integer> stack = new Stack<>();
//(2) 초기 상태
stack.add(/* initialState = */ 0);

//(3) 탐색 진행
while(!stack.isEmpty()) {
    int state = stack.pop();
    
    //(4) 중복 검사
    if(isVisited[state]) continue;
    isVisited[state] = true;
    
    //(5) 현재 상태 처리
    /*현재 상태 state 처리*/
    
    //(6) 전이 상태 생성
    for(int next : getNextStates(state)) {
        //(7) 범위 검사
        if(!/* 범위 검사 조건 */) {
            // 문제 범위를 벗어나는 상태는 제외한다.
            continue;
        }
        
        //(8) 유효성 검사
        if(! /* 유효성 검사 조건 */) {
            // 문제의 조건을 어기는 상태는 제외한다.
            continue;
        }
        
        //(9) 상태 전이
        stack.push(next);
    }
}
```



1. **방문 검사 배열**

   순회하는 상태들의 방문 상태를 담는 배열을 정희한다.
   배열은 상태를 구성하는 상태 변수 개수에 따라 결정되며, 해당 상태의 방문 여부를 담는 boolean 타입의  원소를 갖는다.

   탐색 공간이 너무 커서 배열로 표현하기 힘들다면 Set을 사용할 수 도 있는데,
   이때는 `equals( )` 와 `hasCode( )` 메서드를 오버라이딩 해야한다.

2. **초기 상태**

   스택에 탐색을 시작할 초기 상태를 넣어준다. DFS는 초기 상태부터 진행한다.

3. **탐색 진행**

   스택에는 앞으로 탐색해야 할 탐색 공간이 들어 있다.
   스택이 비워질 때까지 탐색을 진행함으로써 전체 탐색 공간을 탐색할 수 있다.

4. **중복 검사**

   이전에 방문했던 상태를 다시 만날 수도 있기에, 같은 상태를 두 번 검사하는 것을 방지하기 위해 중복 검사를 한다.

5. **현재 상태 처리**

   정답 검사나 값 누적 등 현재 상태를 이용하는 내용을 처리한다.

6. **전이 상태 생성**

   문제의 전이 조건을 이용하여 현재 상태에서 전이될 수 있는 다음 상태들을 생성한다.
   해당 상태들은 범위 검사와 유효성 검사를 이용해서 실제로 전이될 수 있는 상태인지 검사한 후 전이된다.

7. **범위 검사**

   전이 후보 상태가 문제에서 제시된 범위를 벗어나지 않는지 검사한다.
   범위를 벗어난다면 탐색할 필요도 없고 방문 검사 배열에도 담을 수 없기 때문에 다음 전이 후보 상태로 넘어간다.

8. **유효성 검사**

   전이 후보 상태가 유효한 조건인지 검사한다.
   문제 조건을 만족하지 않는 상태라면 실제로 존재할 수 없는 상태이므로 다음 전이 후보 상태로 넘어간다.

9. **상태 전이**

   범위 검사와 유효성 검사를 통과한 전이 후보 상태는 실제로 전이할 수 있느 상태로,
   스택에 넣어서 탐색 공간에 추가한다.

   
